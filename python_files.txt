<files>
<file>
<file_path>app/01_‚ùì_Ask.py</file_path>
<file_content>
import streamlit as st
from components.sidebar import sidebar
from s3 import S3
from utils import query_gpt, query_gpt_memory, show_pdf

st.set_page_config(
    page_title="ClassGPT",
    page_icon="ü§ñ",
    layout="wide",
    initial_sidebar_state="expanded",
    menu_items={
        "Get Help": "https://twitter.com/benthecoder1",
        "Report a bug": "https://github.com/benthecoder/ClassGPT/issues",
        "About": "ClassGPT is a chatbot that answers questions about your pdf files",
    },
)

# Session states
# --------------
if "chosen_class" not in st.session_state:
    st.session_state.chosen_class = "--"

if "chosen_pdf" not in st.session_state:
    st.session_state.chosen_pdf = "--"

if "memory" not in st.session_state:
    st.session_state.memory = ""


sidebar()

st.header("ClassGPT: ChatGPT for your lectures slides")

bucket_name = "classgpt"
s3 = S3(bucket_name)

all_classes = s3.list_files()

chosen_class = st.selectbox(
    "Select a class", list(all_classes.keys()) + ["--"], index=len(all_classes)
)

st.session_state.chosen_class = chosen_class

if st.session_state.chosen_class != "--":
    all_pdfs = all_classes[chosen_class]

    chosen_pdf = st.selectbox(
        "Select a PDF file", all_pdfs + ["--"], index=len(all_pdfs)
    )

    st.session_state.chosen_pdf = chosen_pdf

    if st.session_state.chosen_pdf != "--":
        col1, col2 = st.columns(2)

        with col1:
            st.subheader("Ask a question")
            st.markdown(
                """
                Here are some prompts:
                - `What is the main idea of this lecture in simple terms?`
                - `Summarize the main points of slide 5`
                - `Provide 5 practice questions on this lecture with answers`
                """
            )
            query = st.text_area("Enter your question", max_chars=200)

            if st.button("Ask"):
                if query == "":
                    st.error("Please enter a question")
                with st.spinner("Generating answer..."):
                    # res = query_gpt_memory(chosen_class, chosen_pdf, query)
                    res = query_gpt(chosen_class, chosen_pdf, query)
                    st.markdown(res)

                    # with st.expander("Memory"):
                    #      st.write(st.session_state.memory.replace("\n", "\n\n"))

        with col2:
            show_pdf(chosen_class, chosen_pdf)

</file_content>
<file_context>
<line>
<line_number>0</line_number>
<line_content>import streamlit as st</line_content>
<context>
Changed in version 3.2: The default stream is set to "sys.stderr" at instantiation time rather than import time.</context>
</line>
<line>
<line_number>1</line_number>
<line_content>from components.sidebar import sidebar</line_content>
<context>
import bar</context>
</line>
<line>
<line_number>2</line_number>
<line_content>from s3 import S3</line_content>
<context>
from import.</context>
</line>
<line>
<line_number>3</line_number>
<line_content>from utils import query_gpt, query_gpt_memory, show_pdf</line_content>
<context>
objects. The memory is taken from the Python private heap.</context>
</line>
<line>
<line_number>5</line_number>
<line_content>st.set_page_config(</line_content>
<context>
config_str, const char</context>
</line>
<line>
<line_number>6</line_number>
<line_content>page_title='ClassGPT',</line_content>
<context>
_class</context>
</line>
<line>
<line_number>7</line_number>
<line_content>page_icon='ü§ñ',</line_content>
<context>
python example.py https://example.com/path/page.html</context>
</line>
<line>
<line_number>8</line_number>
<line_content>layout='wide',</line_content>
<context>
width=width</context>
</line>
<line>
<line_number>9</line_number>
<line_content>initial_sidebar_state='expanded',</line_content>
<context>
Empty globals for "bar" are created</context>
</line>
<line>
<line_number>10</line_number>
<line_content>menu_items={</line_content>
<context>
items()</context>
</line>
<line>
<line_number>11</line_number>
<line_content>'Get Help': 'https://twitter.com/benthecoder1',</line_content>
<context>
""help""</context>
</line>
<line>
<line_number>12</line_number>
<line_content>'Report a bug': 'https://github.com/benthecoder/ClassGPT/issues',</line_content>
<context>
A new opcode, "LOAD_CLASSDEREF", has been added to fix a bug in the</context>
</line>
<line>
<line_number>13</line_number>
<line_content>'About': 'ClassGPT is a chatbot that answers questions about your pdf files',</line_content>
<context>
Class.file</context>
</line>
<line>
<line_number>19</line_number>
<line_content>if 'chosen_class' not in st.session_state:</line_content>
<context>
when examining a class in the interactive session. Instead of</context>
</line>
<line>
<line_number>20</line_number>
<line_content>st.session_state.chosen_class = '--'</line_content>
<context>
Classes can further influence how their instances are pickled by overriding the method "__getstate__()". It is called and the returned object is pickled as the contents for the instance, instead of a default state. There are several cases:</context>
</line>
<line>
<line_number>22</line_number>
<line_content>if 'chosen_pdf' not in st.session_state:</line_content>
<context>
Changed in version 3.8: "selection()" no longer takes arguments. For changing the selection state use the following selection methods.</context>
</line>
<line>
<line_number>23</line_number>
<line_content>st.session_state.chosen_pdf = '--'</line_content>
<context>
session</context>
</line>
<line>
<line_number>25</line_number>
<line_content>if 'memory' not in st.session_state:</line_content>
<context>
session*, see "session".</context>
</line>
<line>
<line_number>26</line_number>
<line_content>st.session_state.memory = ''</line_content>
<context>
"session"</context>
</line>
<line>
<line_number>31</line_number>
<line_content>st.header('ClassGPT: ChatGPT for your lectures slides')</line_content>
<context>
Here is the "Header" class description:</context>
</line>
<line>
<line_number>33</line_number>
<line_content>bucket_name = 'classgpt'</line_content>
<context>
class Bucket:  # Note: no base classes ... def __len__(self) -> int: ... def __iter__(self) -> Iterator[int]: ...</context>
</line>
<line>
<line_number>34</line_number>
<line_content>s3 = S3(bucket_name)</line_content>
<context>
s = struct.Struct('ih3s')</context>
</line>
<line>
<line_number>36</line_number>
<line_content>all_classes = s3.list_files()</line_content>
<context>
>>> s.__class__</context>
</line>
<line>
<line_number>38</line_number>
<line_content>chosen_class = st.selectbox(</line_content>
<context>
get_selection()</context>
</line>
<line>
<line_number>39</line_number>
<line_content>'Select a class', list(all_classes.keys()) + ['--'], index=len(all_classes)</line_content>
<context>
How do I get a list of all instances of a given class? ------------------------------------------------------</context>
</line>
<line>
<line_number>42</line_number>
<line_content>st.session_state.chosen_class = chosen_class</line_content>
<context>
Classes can further influence how their instances are pickled by overriding the method "__getstate__()". It is called and the returned object is pickled as the contents for the instance, instead of a default state. There are several cases:</context>
</line>
<line>
<line_number>44</line_number>
<line_content>if st.session_state.chosen_class != '--':</line_content>
<context>
Return "True" if the OptionParser has an option with option string *opt_str* (e.g., "-q" or "--verbose").</context>
</line>
<line>
<line_number>45</line_number>
<line_content>all_pdfs = all_classes[chosen_class]</line_content>
<context>
subclass_of*</context>
</line>
<line>
<line_number>47</line_number>
<line_content>chosen_pdf = st.selectbox(</line_content>
<context>
pdf(x) =  -------------------------------------</context>
</line>
<line>
<line_number>48</line_number>
<line_content>'Select a PDF file', all_pdfs + ['--'], index=len(all_pdfs)</line_content>
<context>
for file in very_long_list_of_files:</context>
</line>
<line>
<line_number>51</line_number>
<line_content>st.session_state.chosen_pdf = chosen_pdf</line_content>
<context>
session</context>
</line>
<line>
<line_number>53</line_number>
<line_content>if st.session_state.chosen_pdf != '--':</line_content>
<context>
Return "True" if the OptionParser has an option with option string *opt_str* (e.g., "-q" or "--verbose").</context>
</line>
<line>
<line_number>54</line_number>
<line_content>col1, col2 = st.columns(2)</line_content>
<context>
[2] Columns:</context>
</line>
<line>
<line_number>56</line_number>
<line_content>with col1:</line_content>
<context>
"COLS".</context>
</line>
<line>
<line_number>57</line_number>
<line_content>st.subheader('Ask a question')</line_content>
<context>
Header</context>
</line>
<line>
<line_number>58</line_number>
<line_content>st.markdown(</line_content>
<context>
"showturtle()" | "st()"</context>
</line>
<line>
<line_number>60</line_number>
<line_content>Here are some prompts:</line_content>
<context>
interactive prompt</context>
</line>
<line>
<line_number>61</line_number>
<line_content>- `What is the main idea of this lecture in simple terms?`</line_content>
<context>
Basic concepts</context>
</line>
<line>
<line_number>62</line_number>
<line_content>- `Summarize the main points of slide 5`</line_content>
<context>
Summarizing:</context>
</line>
<line>
<line_number>63</line_number>
<line_content>- `Provide 5 practice questions on this lecture with answers`</line_content>
<context>
classes, methods, and options.</context>
</line>
<line>
<line_number>66</line_number>
<line_content>query = st.text_area('Enter your question', max_chars=200)</line_content>
<context>
query='',</context>
</line>
<line>
<line_number>68</line_number>
<line_content>if st.button('Ask'):</line_content>
<context>
"'?'". One argument will be consumed from the command line if</context>
</line>
<line>
<line_number>69</line_number>
<line_content>if query == '':</line_content>
<context>
query='',</context>
</line>
<line>
<line_number>70</line_number>
<line_content>st.error('Please enter a question')</line_content>
<context>
This is usually a string explaining the reason for this error.</context>
</line>
<line>
<line_number>71</line_number>
<line_content>with st.spinner('Generating answer...'):</line_content>
<context>
generator expressions.</context>
</line>
<line>
<line_number>72</line_number>
<line_content># res = query_gpt_memory(chosen_class, chosen_pdf, query)</line_content>
<context>
result on MemoryError.</context>
</line>
<line>
<line_number>73</line_number>
<line_content>res = query_gpt(chosen_class, chosen_pdf, query)</line_content>
<context>
selection_set(</context>
</line>
<line>
<line_number>74</line_number>
<line_content>st.markdown(res)</line_content>
<context>
Structured Markup Processing Tools</context>
</line>
<line>
<line_number>76</line_number>
<line_content># with st.expander('Memory'):</line_content>
<context>
"U#" ("str" or "None") [const char *, "Py_ssize_t"] Same as "s#".</context>
</line>
<line>
<line_number>77</line_number>
<line_content>#      st.write(st.session_state.memory.replace('\n', '\n\n'))</line_content>
<context>
sys.stderr.write('%s\n' % s)</context>
</line>
<line>
<line_number>79</line_number>
<line_content>with col2:</line_content>
<context>
"COLS".</context>
</line>
<line>
<line_number>80</line_number>
<line_content>show_pdf(chosen_class, chosen_pdf)</line_content>
<context>
pdf(x)
</context>
</line>
</file_context>
</file>
<file>
<file_path>app/components/sidebar.py</file_path>
<file_content>
import os

import streamlit as st


def sidebar():
    with st.sidebar:
        st.markdown(
            "## How to use\n"
            "1. Add your files in üìÅ Data page\n"
            "2. Ask a question on the ‚ùì Ask page\n"
        )
        api_key_input = st.text_input(
            "OpenAI API Key",
            type="password",
            placeholder="sk-xxx...",
            help="Get an API key here üëâ https://platform.openai.com/account/api-keys.",
            value="",
        )

        if api_key_input:
            os.environ["OPENAI_API_KEY"] = api_key_input
            st.success("API key set")

        st.markdown(
            """
            ---
            ## About

            ClassGPT lets you ask questions about your class \
                lectures and get accurate answers

            This tool is a work in progress.

            Contributions are welcomed on [GitHub](https://github.com/benthecoder/ClassGPT)

            Made with ‚ô•Ô∏è by [Benedict Neo](https://benneo.super.site/)
            """
        )

</file_content>
<file_context>
<line>
<line_number>2</line_number>
<line_content>import streamlit as st</line_content>
<context>
Changed in version 3.2: The default stream is set to "sys.stderr" at instantiation time rather than import time.</context>
</line>
<line>
<line_number>5</line_number>
<line_content>def sidebar():</line_content>
<context>
"bar.py":</context>
</line>
<line>
<line_number>6</line_number>
<line_content>with st.sidebar:</line_content>
<context>
vbar</context>
</line>
<line>
<line_number>7</line_number>
<line_content>st.markdown(</line_content>
<context>
"showturtle()" | "st()"</context>
</line>
<line>
<line_number>8</line_number>
<line_content>'## How to use\n'</line_content>
<context>
'       "       #       \</context>
</line>
<line>
<line_number>9</line_number>
<line_content>'1. Add your files in üìÅ Data page\n'</line_content>
<context>
‚îî‚îÄ‚îÄ please_add.txt</context>
</line>
<line>
<line_number>10</line_number>
<line_content>'2. Ask a question on the ‚ùì Ask page\n'</line_content>
<context>
q" option.</context>
</line>
<line>
<line_number>12</line_number>
<line_content>api_key_input = st.text_input(</line_content>
<context>
get_string(key)</context>
</line>
<line>
<line_number>13</line_number>
<line_content>'OpenAI API Key',</line_content>
<context>
API</context>
</line>
<line>
<line_number>14</line_number>
<line_content>type='password',</line_content>
<context>
Send user command, response should indicate that a password is required.</context>
</line>
<line>
<line_number>15</line_number>
<line_content>placeholder='sk-xxx...',</line_content>
<context>
placeholder</context>
</line>
<line>
<line_number>16</line_number>
<line_content>help='Get an API key here üëâ https://platform.openai.com/account/api-keys.',</line_content>
<context>
API</context>
</line>
<line>
<line_number>20</line_number>
<line_content>if api_key_input:</line_content>
<context>
if key in self:</context>
</line>
<line>
<line_number>21</line_number>
<line_content>os.environ['OPENAI_API_KEY'] = api_key_input</line_content>
<context>
The key identified by the *key* parameter must have been opened with "KEY_SET_VALUE" access.</context>
</line>
<line>
<line_number>22</line_number>
<line_content>st.success('API key set')</line_content>
<context>
On success, return a list of the keys in object *o*. On failure, return "NULL".</context>
</line>
<line>
<line_number>24</line_number>
<line_content>st.markdown(</line_content>
<context>
"showturtle()" | "st()"</context>
</line>
<line>
<line_number>29</line_number>
<line_content>ClassGPT lets you ask questions about your class \</line_content>
<context>
The name of the class.</context>
</line>
<line>
<line_number>30</line_number>
<line_content>lectures and get accurate answers</line_content>
<context>
Classes</context>
</line>
<line>
<line_number>32</line_number>
<line_content>This tool is a work in progress.</line_content>
<context>
"2to3" tool will do most of the work for you.</context>
</line>
<line>
<line_number>34</line_number>
<line_content>Contributions are welcomed on [GitHub](https://github.com/benthecoder/ClassGPT)</line_content>
<context>
The following people contributed code, feedback, design suggestions, previous implementations, and valuable experience to the creation of this module:</context>
</line>
<line>
<line_number>36</line_number>
<line_content>Made with ‚ô•Ô∏è by [Benedict Neo](https://benneo.super.site/)</line_content>
<context>
(Contributed by Raymond Hettinger and incorporating design ideas from Jim Baker, Miki Tebeka, and Nick Coghlan; see recipe 498245, recipe 577479, bpo-10586, and bpo-10593.)
</context>
</line>
</file_context>
</file>
<file>
<file_path>app/pages/02_üìÅ_Data.py</file_path>
<file_content>
import streamlit as st
from components.sidebar import sidebar
from s3 import S3

sidebar()
bucket_name = "classgpt"
s3 = S3(bucket_name)
all_classes = s3.list_files()

tab1, tab2, tab3 = st.tabs(["Upload data", "Add Class", "Delete"])

with tab1:
    st.subheader("Upload new lectures")

    chosen_class = st.selectbox(
        "Select a class",
        list(all_classes.keys()) + ["--"],
        index=len(all_classes),
    )

    if chosen_class != "--":
        with st.form("upload_pdf"):
            uploaded_files = st.file_uploader(
                "Upload a PDF file", type="pdf", accept_multiple_files=True
            )

            submit_button = st.form_submit_button("Upload")

            if submit_button:
                if len(uploaded_files) == 0:
                    st.error("Please upload at least one file")
                else:
                    with st.spinner(f"Uploading {len(uploaded_files)} files..."):
                        for uploaded_file in uploaded_files:
                            s3.upload_files(
                                uploaded_file, f"{chosen_class}/{uploaded_file.name}"
                            )

                        st.success(f"{len(uploaded_files)} files uploaded")


with tab2:
    st.subheader("Add a new class")

    with st.form("add_class"):
        add_class = st.text_input("Enter a new class name")

        submit_button = st.form_submit_button("Add")

        if submit_button:
            if add_class == "":
                st.error("Please enter a class name")
            else:
                s3.create_folder(add_class)
                st.success(f"Class {add_class} added")

with tab3:
    st.subheader("Delete a class or a PDF file")

    chosen_class = st.selectbox(
        "Select a class to delete",
        list(all_classes.keys()) + ["--"],
        index=len(all_classes),
    )

    if chosen_class != "--":
        all_pdfs = all_classes[chosen_class] + ["all"]

        # Remove empty values
        all_pdfs = [x for x in all_pdfs if x]

        chosen_pdf = st.selectbox(
            "Select a PDF file or choose 'all' to delete the whole class",
            all_pdfs + ["--"],
            index=len(all_pdfs),
        )

        if chosen_pdf != "--":
            submit_button = st.button("Remove")

            if submit_button:
                if chosen_pdf == "all":
                    s3.remove_folder(chosen_class)
                    st.success(f"{chosen_class} removed")
                else:
                    s3.remove_file(chosen_class, chosen_pdf)
                    st.success(f"{chosen_pdf} removed")

</file_content>
<file_context>
<line>
<line_number>0</line_number>
<line_content>import streamlit as st</line_content>
<context>
Changed in version 3.2: The default stream is set to "sys.stderr" at instantiation time rather than import time.</context>
</line>
<line>
<line_number>1</line_number>
<line_content>from components.sidebar import sidebar</line_content>
<context>
import bar</context>
</line>
<line>
<line_number>2</line_number>
<line_content>from s3 import S3</line_content>
<context>
from import.</context>
</line>
<line>
<line_number>5</line_number>
<line_content>bucket_name = 'classgpt'</line_content>
<context>
class Bucket:  # Note: no base classes ... def __len__(self) -> int: ... def __iter__(self) -> Iterator[int]: ...</context>
</line>
<line>
<line_number>6</line_number>
<line_content>s3 = S3(bucket_name)</line_content>
<context>
s = struct.Struct('ih3s')</context>
</line>
<line>
<line_number>7</line_number>
<line_content>all_classes = s3.list_files()</line_content>
<context>
>>> s.__class__</context>
</line>
<line>
<line_number>9</line_number>
<line_content>tab1, tab2, tab3 = st.tabs(['Upload data', 'Add Class', 'Delete'])</line_content>
<context>
tab(tab_id, option=None, *</context>
</line>
<line>
<line_number>11</line_number>
<line_content>with tab1:</line_content>
<context>
tab</context>
</line>
<line>
<line_number>12</line_number>
<line_content>st.subheader('Upload new lectures')</line_content>
<context>
ContentTransferEncodingHeader</context>
</line>
<line>
<line_number>14</line_number>
<line_content>chosen_class = st.selectbox(</line_content>
<context>
get_selection()</context>
</line>
<line>
<line_number>15</line_number>
<line_content>'Select a class',</line_content>
<context>
class selectors.SelectSelector</context>
</line>
<line>
<line_number>16</line_number>
<line_content>list(all_classes.keys()) + ['--'],</line_content>
<context>
class list([iterable])</context>
</line>
<line>
<line_number>17</line_number>
<line_content>index=len(all_classes),</line_content>
<context>
How do I get a list of all instances of a given class? ------------------------------------------------------</context>
</line>
<line>
<line_number>20</line_number>
<line_content>if chosen_class != '--':</line_content>
<context>
selection_set(</context>
</line>
<line>
<line_number>21</line_number>
<line_content>with st.form('upload_pdf'):</line_content>
<context>
The file upload draft standard entertains the possibility of uploading multiple files from one field (using a recursive *multipart/** encoding). When this occurs, the item will be a dictionary-like "FieldStorage" item. This can be determined by testing its "type" attribute, which should be *multipart/form-data* (or perhaps another MIME type matching *multipart/**). In this case, it can be iterated over recursively just like the top-level form object.</context>
</line>
<line>
<line_number>22</line_number>
<line_content>uploaded_files = st.file_uploader(</line_content>
<context>
("__file__")</context>
</line>
<line>
<line_number>23</line_number>
<line_content>'Upload a PDF file', type='pdf', accept_multiple_files=True</line_content>
<context>
The file upload draft standard entertains the possibility of uploading multiple files from one field (using a recursive *multipart/** encoding). When this occurs, the item will be a dictionary-like "FieldStorage" item. This can be determined by testing its "type" attribute, which should be *multipart/form-data* (or perhaps another MIME type matching *multipart/**). In this case, it can be iterated over recursively just like the top-level form object.</context>
</line>
<line>
<line_number>26</line_number>
<line_content>submit_button = st.form_submit_button('Upload')</line_content>
<context>
*fn* in the "submit()" method of</context>
</line>
<line>
<line_number>28</line_number>
<line_content>if submit_button:</line_content>
<context>
do_POST()</context>
</line>
<line>
<line_number>29</line_number>
<line_content>if len(uploaded_files) == 0:</line_content>
<context>
self.file_count = 0</context>
</line>
<line>
<line_number>30</line_number>
<line_content>st.error('Please upload at least one file')</line_content>
<context>
"FileExistsError"</context>
</line>
<line>
<line_number>32</line_number>
<line_content>with st.spinner(f'Uploading {len(uploaded_files)} files...'):</line_content>
<context>
Filename ("str").</context>
</line>
<line>
<line_number>33</line_number>
<line_content>for uploaded_file in uploaded_files:</line_content>
<context>
def is_image_file (filename):</context>
</line>
<line>
<line_number>34</line_number>
<line_content>s3.upload_files(</line_content>
<context>
("__file__")</context>
</line>
<line>
<line_number>35</line_number>
<line_content>uploaded_file, f'{chosen_class}/{uploaded_file.name}'</line_content>
<context>
("__file__")</context>
</line>
<line>
<line_number>38</line_number>
<line_content>st.success(f'{len(uploaded_files)} files uploaded')</line_content>
<context>
Request the size of the file named *filename* on the server. On success, the size of the file is returned as an integer, otherwise "None" is returned. Note that the "SIZE" command is not standardized, but is supported by many common server implementations.</context>
</line>
<line>
<line_number>41</line_number>
<line_content>with tab2:</line_content>
<context>
tab</context>
</line>
<line>
<line_number>42</line_number>
<line_content>st.subheader('Add a new class')</line_content>
<context>
Construct and return a class to handle creating a *name* header.</context>
</line>
<line>
<line_number>44</line_number>
<line_content>with st.form('add_class'):</line_content>
<context>
different class (for example, setting "__add__ = str.__add__" on an</context>
</line>
<line>
<line_number>45</line_number>
<line_content>add_class = st.text_input('Enter a new class name')</line_content>
<context>
different class (for example, setting "__add__ = str.__add__" on an</context>
</line>
<line>
<line_number>47</line_number>
<line_content>submit_button = st.form_submit_button('Add')</line_content>
<context>
The add_argument() method</context>
</line>
<line>
<line_number>49</line_number>
<line_content>if submit_button:</line_content>
<context>
do_POST()</context>
</line>
<line>
<line_number>50</line_number>
<line_content>if add_class == '':</line_content>
<context>
it and unittest in   'if __name__ == '__main__'. * Add class</context>
</line>
<line>
<line_number>51</line_number>
<line_content>st.error('Please enter a class name')</line_content>
<context>
class, so it would a bit clear that it's an error with the invalid</context>
</line>
<line>
<line_number>53</line_number>
<line_content>s3.create_folder(add_class)</line_content>
<context>
add_folder(folder)</context>
</line>
<line>
<line_number>54</line_number>
<line_content>st.success(f'Class {add_class} added')</line_content>
<context>
return __class__</context>
</line>
<line>
<line_number>56</line_number>
<line_content>with tab3:</line_content>
<context>
tab</context>
</line>
<line>
<line_number>57</line_number>
<line_content>st.subheader('Delete a class or a PDF file')</line_content>
<context>
Here is the "Header" class description:</context>
</line>
<line>
<line_number>59</line_number>
<line_content>chosen_class = st.selectbox(</line_content>
<context>
get_selection()</context>
</line>
<line>
<line_number>60</line_number>
<line_content>'Select a class to delete',</line_content>
<context>
del MyClass</context>
</line>
<line>
<line_number>61</line_number>
<line_content>list(all_classes.keys()) + ['--'],</line_content>
<context>
class list([iterable])</context>
</line>
<line>
<line_number>62</line_number>
<line_content>index=len(all_classes),</line_content>
<context>
How do I get a list of all instances of a given class? ------------------------------------------------------</context>
</line>
<line>
<line_number>65</line_number>
<line_content>if chosen_class != '--':</line_content>
<context>
selection_set(</context>
</line>
<line>
<line_number>66</line_number>
<line_content>all_pdfs = all_classes[chosen_class] + ['all']</line_content>
<context>
get_all(name)</context>
</line>
<line>
<line_number>68</line_number>
<line_content># Remove empty values</line_content>
<context>
Omitting values</context>
</line>
<line>
<line_number>69</line_number>
<line_content>all_pdfs = [x for x in all_pdfs if x]</line_content>
<context>
return "False". "all()" returns "True" only if all of the values</context>
</line>
<line>
<line_number>71</line_number>
<line_content>chosen_pdf = st.selectbox(</line_content>
<context>
pdf(x) =  -------------------------------------</context>
</line>
<line>
<line_number>72</line_number>
<line_content>'Select a PDF file or choose 'all' to delete the whole class',</line_content>
<context>
cleans up the particular class.</context>
</line>
<line>
<line_number>73</line_number>
<line_content>all_pdfs + ['--'],</line_content>
<context>
print(' |-</context>
</line>
<line>
<line_number>74</line_number>
<line_content>index=len(all_pdfs),</line_content>
<context>
for index in range(len(data)</context>
</line>
<line>
<line_number>77</line_number>
<line_content>if chosen_pdf != '--':</line_content>
<context>
Return "True" if the OptionParser has an option with option string *opt_str* (e.g., "-q" or "--verbose").</context>
</line>
<line>
<line_number>78</line_number>
<line_content>submit_button = st.button('Remove')</line_content>
<context>
def remove_task(task): 'Mark an existing task as REMOVED. Raise KeyError if not found.' entry = entry_finder.pop(task) entry[-1] = REMOVED</context>
</line>
<line>
<line_number>80</line_number>
<line_content>if submit_button:</line_content>
<context>
do_POST()</context>
</line>
<line>
<line_number>81</line_number>
<line_content>if chosen_pdf == 'all':</line_content>
<context>
You can select only certain elements by adding an ""if"" condition:</context>
</line>
<line>
<line_number>82</line_number>
<line_content>s3.remove_folder(chosen_class)</line_content>
<context>
remove_folder(folder)</context>
</line>
<line>
<line_number>83</line_number>
<line_content>st.success(f'{chosen_class} removed')</line_content>
<context>
selection_remove(</context>
</line>
<line>
<line_number>85</line_number>
<line_content>s3.remove_file(chosen_class, chosen_pdf)</line_content>
<context>
Update the current file selection to *file*.</context>
</line>
<line>
<line_number>86</line_number>
<line_content>st.success(f'{chosen_pdf} removed')</line_content>
<context>
selection_remove(
</context>
</line>
</file_context>
</file>
<file>
<file_path>app/s3.py</file_path>
<file_content>
from collections import defaultdict

import boto3
import botocore


class S3:
    """
    Class for interacting with S3

    Args:
        bucket_name (str): Name of the S3 bucket

    Attributes:
        bucket_name (str): Name of the S3 bucket
        s3 (boto3.resource): S3 resource
        bucket (boto3.Bucket): S3 bucket

    Methods:
        list_folders: List all folders in the S3 bucket
        list_files: List all files in the S3 bucket
        folder_exists: Check if a folder exists in the S3 bucket
        file_exists: Check if a file exists in the S3 bucket
        create_folder: Create a folder in the S3 bucket
        upload_files: Upload a file to the S3 bucket
        remove_folder: Remove a folder from the S3 bucket
        remove_file: Remove a file from the S3 bucket
    """

    def __init__(self, bucket_name):
        self.bucket_name = bucket_name
        self.s3 = boto3.resource("s3")
        self.bucket = self.s3.Bucket(bucket_name)

    def list_folders(self):
        folders = set()
        for obj in self.bucket.objects.filter():
            folders.add(obj.key.split("/")[0])

        return folders

    def list_files(self):
        classes = defaultdict(list)

        # loop through only the parent directory
        for obj in self.bucket.objects.filter():
            cname, fname = obj.key.split("/")
            if not fname.endswith(".json"):
                classes[cname].append(fname)

        return classes

    def folder_exists(self, folder_name):
        for _ in self.bucket.objects.filter(Prefix=f"{folder_name}/"):
            return True
        return False

    def file_exists(self, folder_name, file_name):
        try:
            self.s3.Object(self.bucket_name, f"{folder_name}/{file_name}").load()
            return True
        except botocore.exceptions.ClientError as e:
            if e.response["Error"]["Code"] == "404":
                return False
            else:
                raise

    def create_folder(self, folder_name):
        if not self.folder_exists(folder_name):
            self.bucket.put_object(Key=f"{folder_name}/")

    def upload_files(self, file_obj, file_path):
        self.bucket.upload_fileobj(file_obj, file_path)

    def remove_folder(self, folder_name):
        if self.folder_exists(folder_name):
            for key in self.bucket.objects.filter(Prefix=f"{folder_name}/"):
                key.delete()

    def remove_file(self, folder_name, file_name):
        if self.folder_exists(folder_name):
            self.bucket.objects.filter(Prefix=f"{folder_name}/{file_name}").delete(
                Delete={"Objects": [{"Key": f"{folder_name}/{file_name}"}]}
            )

    def download_file(self, from_file_path, to_file_path):
        self.bucket.download_file(from_file_path, to_file_path)

</file_content>
<file_context>
<line>
<line_number>0</line_number>
<line_content>from collections import defaultdict</line_content>
<context>
"collections.defaultdict"</context>
</line>
<line>
<line_number>2</line_number>
<line_content>import boto3</line_content>
<context>
>>> import custom3</context>
</line>
<line>
<line_number>3</line_number>
<line_content>import botocore</line_content>
<context>
>>> import urllib.robotparser</context>
</line>
<line>
<line_number>8</line_number>
<line_content>Class for interacting with S3</line_content>
<context>
>>> s.__class__</context>
</line>
<line>
<line_number>11</line_number>
<line_content>bucket_name (str): Name of the S3 bucket</line_content>
<context>
class Bucket:  # Note: no base classes ... def __len__(self) -> int: ... def __iter__(self) -> Iterator[int]: ...</context>
</line>
<line>
<line_number>13</line_number>
<line_content>Attributes:</line_content>
<context>
Attributes:</context>
</line>
<line>
<line_number>14</line_number>
<line_content>bucket_name (str): Name of the S3 bucket</line_content>
<context>
class Bucket:  # Note: no base classes ... def __len__(self) -> int: ... def __iter__(self) -> Iterator[int]: ...</context>
</line>
<line>
<line_number>15</line_number>
<line_content>s3 (boto3.resource): S3 resource</line_content>
<context>
"resource" --</context>
</line>
<line>
<line_number>16</line_number>
<line_content>bucket (boto3.Bucket): S3 bucket</line_content>
<context>
class Bucket:  # Note: no base classes ... def __len__(self) -> int: ... def __iter__(self) -> Iterator[int]: ...</context>
</line>
<line>
<line_number>19</line_number>
<line_content>list_folders: List all folders in the S3 bucket</line_content>
<context>
list_folders()</context>
</line>
<line>
<line_number>20</line_number>
<line_content>list_files: List all files in the S3 bucket</line_content>
<context>
for file in very_long_list_of_files:</context>
</line>
<line>
<line_number>21</line_number>
<line_content>folder_exists: Check if a folder exists in the S3 bucket</line_content>
<context>
New in version 3.8: The *dirs_exist_ok* parameter.</context>
</line>
<line>
<line_number>22</line_number>
<line_content>file_exists: Check if a file exists in the S3 bucket</line_content>
<context>
# Return 200 OK if file exists, otherwise 404 Not Found if os.path.exists(fn): respond("200 OK", [("Content-Type", mime_type)]) return util.FileWrapper(open(fn, "rb")) else: respond("404 Not Found", [("Content-Type", "text/plain")]) return [b"not found"]</context>
</line>
<line>
<line_number>23</line_number>
<line_content>create_folder: Create a folder in the S3 bucket</line_content>
<context>
add_folder(folder)</context>
</line>
<line>
<line_number>24</line_number>
<line_content>upload_files: Upload a file to the S3 bucket</line_content>
<context>
The file upload draft standard entertains the possibility of uploading multiple files from one field (using a recursive *multipart/** encoding). When this occurs, the item will be a dictionary-like "FieldStorage" item. This can be determined by testing its "type" attribute, which should be *multipart/form-data* (or perhaps another MIME type matching *multipart/**). In this case, it can be iterated over recursively just like the top-level form object.</context>
</line>
<line>
<line_number>25</line_number>
<line_content>remove_folder: Remove a folder from the S3 bucket</line_content>
<context>
remove_folder(folder)</context>
</line>
<line>
<line_number>26</line_number>
<line_content>remove_file: Remove a file from the S3 bucket</line_content>
<context>
os.remove('somefile.tmp')</context>
</line>
<line>
<line_number>29</line_number>
<line_content>def __init__(self, bucket_name):</line_content>
<context>
def __init__(self, name):</context>
</line>
<line>
<line_number>30</line_number>
<line_content>self.bucket_name = bucket_name</line_content>
<context>
self._name = name</context>
</line>
<line>
<line_number>31</line_number>
<line_content>self.s3 = boto3.resource('s3')</line_content>
<context>
s = struct.Struct('ih3s')</context>
</line>
<line>
<line_number>32</line_number>
<line_content>self.bucket = self.s3.Bucket(bucket_name)</line_content>
<context>
class Bucket:  # Note: no base classes ... def __len__(self) -> int: ... def __iter__(self) -> Iterator[int]: ...</context>
</line>
<line>
<line_number>34</line_number>
<line_content>def list_folders(self):</line_content>
<context>
list_folders()</context>
</line>
<line>
<line_number>35</line_number>
<line_content>folders = set()</line_content>
<context>
list_folders()</context>
</line>
<line>
<line_number>36</line_number>
<line_content>for obj in self.bucket.objects.filter():</line_content>
<context>
Filter Objects</context>
</line>
<line>
<line_number>37</line_number>
<line_content>folders.add(obj.key.split('/')[0])</line_content>
<context>
os.listdir(path='.')</context>
</line>
<line>
<line_number>39</line_number>
<line_content>return folders</line_content>
<context>
Return a list of the names of all folders.</context>
</line>
<line>
<line_number>41</line_number>
<line_content>def list_files(self):</line_content>
<context>
self.the_list = the_list</context>
</line>
<line>
<line_number>42</line_number>
<line_content>classes = defaultdict(list)</line_content>
<context>
"defaultdict" objects</context>
</line>
<line>
<line_number>44</line_number>
<line_content># loop through only the parent directory</line_content>
<context>
Enumerate the children of the current directory.</context>
</line>
<line>
<line_number>45</line_number>
<line_content>for obj in self.bucket.objects.filter():</line_content>
<context>
Filter Objects</context>
</line>
<line>
<line_number>46</line_number>
<line_content>cname, fname = obj.key.split('/')</line_content>
<context>
>>> 'www.python.org'.split('. ', 1)</context>
</line>
<line>
<line_number>47</line_number>
<line_content>if not fname.endswith('.json'):</line_content>
<context>
json.dump(x, f)</context>
</line>
<line>
<line_number>48</line_number>
<line_content>classes[cname].append(fname)</line_content>
<context>
cls.subclasses.append(cls)</context>
</line>
<line>
<line_number>50</line_number>
<line_content>return classes</line_content>
<context>
return __class__</context>
</line>
<line>
<line_number>52</line_number>
<line_content>def folder_exists(self, folder_name):</line_content>
<context>
>>> Path('setup.py').exists()</context>
</line>
<line>
<line_number>53</line_number>
<line_content>for _ in self.bucket.objects.filter(Prefix=f'{folder_name}/'):</line_content>
<context>
object_filenames(source_filenames[, strip_dir=0, output_dir=''])</context>
</line>
<line>
<line_number>54</line_number>
<line_content>return True</line_content>
<context>
return True</context>
</line>
<line>
<line_number>55</line_number>
<line_content>return False</line_content>
<context>
return False</context>
</line>
<line>
<line_number>57</line_number>
<line_content>def file_exists(self, folder_name, file_name):</line_content>
<context>
>>> os.path.exists(f.name)</context>
</line>
<line>
<line_number>59</line_number>
<line_content>self.s3.Object(self.bucket_name, f'{folder_name}/{file_name}').load()</line_content>
<context>
New in version 3.6.1: The *filenames* parameter accepts a *path- like object*.</context>
</line>
<line>
<line_number>60</line_number>
<line_content>return True</line_content>
<context>
return True</context>
</line>
<line>
<line_number>61</line_number>
<line_content>except botocore.exceptions.ClientError as e:</line_content>
<context>
This exception is a subclass of "EOFError".</context>
</line>
<line>
<line_number>62</line_number>
<line_content>if e.response['Error']['Code'] == '404':</line_content>
<context>
Return data for response *code* if received, or "None". Returns the given code, instead of the usual type.</context>
</line>
<line>
<line_number>63</line_number>
<line_content>return False</line_content>
<context>
return False</context>
</line>
<line>
<line_number>67</line_number>
<line_content>def create_folder(self, folder_name):</line_content>
<context>
add_folder(folder)</context>
</line>
<line>
<line_number>68</line_number>
<line_content>if not self.folder_exists(folder_name):</line_content>
<context>
add_folder(folder)</context>
</line>
<line>
<line_number>69</line_number>
<line_content>self.bucket.put_object(Key=f'{folder_name}/')</line_content>
<context>
class Bucket:  # Note: no base classes ... def __len__(self) -> int: ... def __iter__(self) -> Iterator[int]: ...</context>
</line>
<line>
<line_number>71</line_number>
<line_content>def upload_files(self, file_obj, file_path):</line_content>
<context>
def is_image_file (filename):</context>
</line>
<line>
<line_number>72</line_number>
<line_content>self.bucket.upload_fileobj(file_obj, file_path)</line_content>
<context>
file as file_obj: object</context>
</line>
<line>
<line_number>74</line_number>
<line_content>def remove_folder(self, folder_name):</line_content>
<context>
remove_folder(folder)</context>
</line>
<line>
<line_number>75</line_number>
<line_content>if self.folder_exists(folder_name):</line_content>
<context>
Return True if self is a directory.</context>
</line>
<line>
<line_number>76</line_number>
<line_content>for key in self.bucket.objects.filter(Prefix=f'{folder_name}/'):</line_content>
<context>
object_filenames(source_filenames[, strip_dir=0, output_dir=''])</context>
</line>
<line>
<line_number>77</line_number>
<line_content>key.delete()</line_content>
<context>
remove(key)</context>
</line>
<line>
<line_number>79</line_number>
<line_content>def remove_file(self, folder_name, file_name):</line_content>
<context>
remove_folder(folder)</context>
</line>
<line>
<line_number>80</line_number>
<line_content>if self.folder_exists(folder_name):</line_content>
<context>
Return True if self is a directory.</context>
</line>
<line>
<line_number>81</line_number>
<line_content>self.bucket.objects.filter(Prefix=f'{folder_name}/{file_name}').delete(</line_content>
<context>
remove_folder(folder)</context>
</line>
<line>
<line_number>82</line_number>
<line_content>Delete={'Objects': [{'Key': f'{folder_name}/{file_name}'}]}</line_content>
<context>
object.__delitem__(self, key)</context>
</line>
<line>
<line_number>85</line_number>
<line_content>def download_file(self, from_file_path, to_file_path):</line_content>
<context>
Path.is_file()</context>
</line>
<line>
<line_number>86</line_number>
<line_content>self.bucket.download_file(from_file_path, to_file_path)</line_content>
<context>
self.filename = filename
</context>
</line>
</file_context>
</file>
<file>
<file_path>app/utils.py</file_path>
<file_content>
import base64
import logging
import os
import sys
import tempfile
from io import BytesIO

import openai
import streamlit as st
from dotenv import load_dotenv
from langchain import OpenAI

# langchain
from langchain.agents import Tool, initialize_agent
from langchain.chains.conversation.memory import ConversationBufferMemory
from langchain.chat_models import ChatOpenAI

# llama_index
from llama_index import Document, GPTSimpleVectorIndex, LLMPredictor
from pypdf import PdfReader
from s3 import S3

# set to DEBUG for more verbose logging
logging.basicConfig(stream=sys.stdout, level=logging.INFO)


load_dotenv()
if os.getenv("OPENAI_API_KEY") is None:
    st.error("OpenAI API key not set")
else:
    openai.api_key = os.getenv("OPENAI_API_KEY")


s3 = S3("classgpt")


# ------------------- index creation ------------------- #


def parse_pdf(file: BytesIO):

    pdf = PdfReader(file)
    text_list = []

    # Get the number of pages in the PDF document
    num_pages = len(pdf.pages)

    # Iterate over every page
    for page in range(num_pages):
        # Extract the text from the page
        page_text = pdf.pages[page].extract_text()
        text_list.append(page_text)

    text = "\n".join(text_list)

    return [Document(text)]


def create_index(pdf_obj, folder_name, file_name):
    """
    Create an index for a given PDF file and upload it to S3.
    """
    index_name = file_name.replace(".pdf", ".json")

    logging.info("Generating new index...")
    documents = parse_pdf(pdf_obj)

    logging.info("Creating index...")
    index = GPTSimpleVectorIndex(documents)

    with tempfile.TemporaryDirectory() as tmp_dir:
        tmp_path = f"{tmp_dir}/{index_name}"
        logging.info("Saving index...")
        index.save_to_disk(tmp_path)

        with open(tmp_path, "rb") as f:
            logging.info("Uploading index to s3...")
            s3.upload_files(f, f"{folder_name}/{index_name}")

    return index


@st.cache_resource(show_spinner=False)
def get_index(folder_name, file_name):
    """
    Get the index for a given PDF file.
    """
    index_name = file_name.replace(".pdf", ".json")
    index = None

    if s3.file_exists(folder_name, index_name):
        logging.info("Index found, loading index...")
        with tempfile.TemporaryDirectory() as tmp_dir:
            tmp_path = f"{tmp_dir}/{index_name}"
            s3.download_file(f"{folder_name}/{index_name}", tmp_path)
            index = GPTSimpleVectorIndex.load_from_disk(tmp_path)

    else:
        logging.info("Index not found, generating index...")
        with tempfile.NamedTemporaryFile("wb") as f_src:
            logging.info(f"{file_name} downloaded")
            s3.download_file(f"{folder_name}/{file_name}", f_src.name)

            with open(f_src.name, "rb") as f:
                index = create_index(f, folder_name, file_name)

    return index


def query_gpt(chosen_class, chosen_pdf, query):

    if not os.getenv("OPENAI_API_KEY"):
        st.error("Enter your OpenAI API key in the sidebar.")
        st.stop()

    # LLM Predictor (gpt-3.5-turbo)
    llm_predictor = LLMPredictor(
        llm=ChatOpenAI(
            temperature=0,
            model_name="gpt-3.5-turbo",
        )
    )

    index = get_index(chosen_class, chosen_pdf)
    response = index.query(query, llm_predictor=llm_predictor)

    # logging.info(response.get_formatted_sources())

    return response


@st.cache_resource
def create_tool(_index, chosen_pdf):
    tools = [
        Tool(
            name=f"{chosen_pdf} index",
            func=lambda q: str(_index.query(q)),
            description="Useful to answering questions about the given file",
            return_direct=True,
        ),
    ]

    return tools


@st.cache_resource
def create_agent(chosen_class, chosen_pdf):
    memory = ConversationBufferMemory(memory_key="chat_history")
    llm = OpenAI(temperature=0, model_name="gpt-3.5-turbo")

    index = get_index(chosen_class, chosen_pdf)
    tools = create_tool(index, chosen_pdf)

    agent = initialize_agent(
        tools, llm, agent="conversational-react-description", memory=memory
    )

    return agent


def query_gpt_memory(chosen_class, chosen_pdf, query):

    agent = create_agent(chosen_class, chosen_pdf)
    res = ""

    try:
        res = agent.run(input=query)
    except Exception as e:
        logging.error(e)
        res = "Something went wrong... Please try again."

    st.session_state.memory = agent.memory.buffer

    return res


# ------------------- Render PDF ------------------- #


@st.cache_data
def show_pdf(folder_name, file_name):

    with tempfile.NamedTemporaryFile("wb") as f_src:
        logging.info(f"Downloading {file_name}...")
        s3.download_file(f"{folder_name}/{file_name}", f_src.name)

        with open(f_src.name, "rb") as f:
            base64_pdf = base64.b64encode(f.read()).decode("utf-8")

        pdf_display = f"""
        <iframe
            src="data:application/pdf;base64,{base64_pdf}"
            width="100%" height="1000"
            type="application/pdf"
            style="min-width: 400px;"
        >
        </iframe>
        """

        st.markdown(pdf_display, unsafe_allow_html=True)

</file_content>
<file_context>
<line>
<line_number>0</line_number>
<line_content>import base64</line_content>
<context>
import base64</context>
</line>
<line>
<line_number>1</line_number>
<line_content>import logging</line_content>
<context>
import logging</context>
</line>
<line>
<line_number>3</line_number>
<line_content>import sys</line_content>
<context>
import sys</context>
</line>
<line>
<line_number>4</line_number>
<line_content>import tempfile</line_content>
<context>
import tempfile</context>
</line>
<line>
<line_number>5</line_number>
<line_content>from io import BytesIO</line_content>
<context>
from io import StringIO</context>
</line>
<line>
<line_number>7</line_number>
<line_content>import openai</line_content>
<context>
import</context>
</line>
<line>
<line_number>8</line_number>
<line_content>import streamlit as st</line_content>
<context>
Changed in version 3.2: The default stream is set to "sys.stderr" at instantiation time rather than import time.</context>
</line>
<line>
<line_number>9</line_number>
<line_content>from dotenv import load_dotenv</line_content>
<context>
"importlib.util.module_for_loader()"</context>
</line>
<line>
<line_number>10</line_number>
<line_content>from langchain import OpenAI</line_content>
<context>
import locale</context>
</line>
<line>
<line_number>13</line_number>
<line_content>from langchain.agents import Tool, initialize_agent</line_content>
<context>
**This module is automatically imported during initialization. ** The automatic import can be suppressed using the interpreter's "-S" option.</context>
</line>
<line>
<line_number>14</line_number>
<line_content>from langchain.chains.conversation.memory import ConversationBufferMemory</line_content>
<context>
Speaking logging messages</context>
</line>
<line>
<line_number>15</line_number>
<line_content>from langchain.chat_models import ChatOpenAI</line_content>
<context>
>>> import locale</context>
</line>
<line>
<line_number>18</line_number>
<line_content>from llama_index import Document, GPTSimpleVectorIndex, LLMPredictor</line_content>
<context>
>>> t.index(3)</context>
</line>
<line>
<line_number>19</line_number>
<line_content>from pypdf import PdfReader</line_content>
<context>
"P_PIDFD" is only available on Linux >= 5.4.</context>
</line>
<line>
<line_number>20</line_number>
<line_content>from s3 import S3</line_content>
<context>
from import.</context>
</line>
<line>
<line_number>23</line_number>
<line_content>logging.basicConfig(stream=sys.stdout, level=logging.INFO)</line_content>
<context>
logging.basicConfig(level=logging.INFO)</context>
</line>
<line>
<line_number>26</line_number>
<line_content>load_dotenv()</line_content>
<context>
load()</context>
</line>
<line>
<line_number>27</line_number>
<line_content>if os.getenv('OPENAI_API_KEY') is None:</line_content>
<context>
os.getenv(key, default=None)</context>
</line>
<line>
<line_number>28</line_number>
<line_content>st.error('OpenAI API key not set')</line_content>
<context>
The key identified by the *key* parameter must have been opened with "KEY_SET_VALUE" access.</context>
</line>
<line>
<line_number>30</line_number>
<line_content>openai.api_key = os.getenv('OPENAI_API_KEY')</line_content>
<context>
os.getenv(key, default=None)</context>
</line>
<line>
<line_number>33</line_number>
<line_content>s3 = S3('classgpt')</line_content>
<context>
>>> s.__class__</context>
</line>
<line>
<line_number>39</line_number>
<line_content>def parse_pdf(file: BytesIO):</line_content>
<context>
Similar to the "parse()" method, except it takes a *bytes-like object* instead of a file-like object. Calling this method on a *bytes-like object* is equivalent to wrapping *bytes* in a "BytesIO" instance first and calling "parse()".</context>
</line>
<line>
<line_number>41</line_number>
<line_content>pdf = PdfReader(file)</line_content>
<context>
pdf(x)</context>
</line>
<line>
<line_number>42</line_number>
<line_content>text_list = []</line_content>
<context>
>>> a_list = []</context>
</line>
<line>
<line_number>44</line_number>
<line_content># Get the number of pages in the PDF document</line_content>
<context>
**pages** (*int*) -- The number of pages to copy at a time.</context>
</line>
<line>
<line_number>45</line_number>
<line_content>num_pages = len(pdf.pages)</line_content>
<context>
**pages** (*int*) -- The number of pages to copy at a time.</context>
</line>
<line>
<line_number>47</line_number>
<line_content># Iterate over every page</line_content>
<context>
each iteration.</context>
</line>
<line>
<line_number>48</line_number>
<line_content>for page in range(num_pages):</line_content>
<context>
for num in range(10):</context>
</line>
<line>
<line_number>49</line_number>
<line_content># Extract the text from the page</line_content>
<context>
# Get resulting contents</context>
</line>
<line>
<line_number>50</line_number>
<line_content>page_text = pdf.pages[page].extract_text()</line_content>
<context>
the_page = response.read()</context>
</line>
<line>
<line_number>51</line_number>
<line_content>text_list.append(page_text)</line_content>
<context>
LIST_APPEND(i)</context>
</line>
<line>
<line_number>53</line_number>
<line_content>text = '\n'.join(text_list)</line_content>
<context>
"\n".join(wrap(text, ...))</context>
</line>
<line>
<line_number>55</line_number>
<line_content>return [Document(text)]</line_content>
<context>
Both functions return a "Document" object representing the content of the document.</context>
</line>
<line>
<line_number>58</line_number>
<line_content>def create_index(pdf_obj, folder_name, file_name):</line_content>
<context>
def __index__ (self):</context>
</line>
<line>
<line_number>60</line_number>
<line_content>Create an index for a given PDF file and upload it to S3.</line_content>
<context>
e.submit(shutil.copy, 'src3.txt', 'dest3.txt')</context>
</line>
<line>
<line_number>62</line_number>
<line_content>index_name = file_name.replace('.pdf', '.json')</line_content>
<context>
$ python -m json.tool mp_films.json [ { "title": "And Now for Something Completely Different", "year": 1971 }, { "title": "Monty Python and the Holy Grail", "year": 1975 } ]</context>
</line>
<line>
<line_number>64</line_number>
<line_content>logging.info('Generating new index...')</line_content>
<context>
logging.info('Doing something')</context>
</line>
<line>
<line_number>65</line_number>
<line_content>documents = parse_pdf(pdf_obj)</line_content>
<context>
pdf(x) =  -------------------------------------</context>
</line>
<line>
<line_number>67</line_number>
<line_content>logging.info('Creating index...')</line_content>
<context>
logging.info('Doing something')</context>
</line>
<line>
<line_number>68</line_number>
<line_content>index = GPTSimpleVectorIndex(documents)</line_content>
<context>
>>> t.index(3)</context>
</line>
<line>
<line_number>70</line_number>
<line_content>with tempfile.TemporaryDirectory() as tmp_dir:</line_content>
<context>
with tempfile.TemporaryDirectory() as tmpdirname:</context>
</line>
<line>
<line_number>71</line_number>
<line_content>tmp_path = f'{tmp_dir}/{index_name}'</line_content>
<context>
directory /tmp/</context>
</line>
<line>
<line_number>72</line_number>
<line_content>logging.info('Saving index...')</line_content>
<context>
logging.info('Doing something')</context>
</line>
<line>
<line_number>73</line_number>
<line_content>index.save_to_disk(tmp_path)</line_content>
<context>
Path.write_bytes(data)</context>
</line>
<line>
<line_number>75</line_number>
<line_content>with open(tmp_path, 'rb') as f:</line_content>
<context>
with open(sys.argv[1], 'rb') as f: data_to_send = f.read()</context>
</line>
<line>
<line_number>76</line_number>
<line_content>logging.info('Uploading index to s3...')</line_content>
<context>
logging.info('Doing something')</context>
</line>
<line>
<line_number>77</line_number>
<line_content>s3.upload_files(f, f'{folder_name}/{index_name}')</line_content>
<context>
Changed in version 3.11: Accepts *path-like object* for filename.</context>
</line>
<line>
<line_number>79</line_number>
<line_content>return index</line_content>
<context>
index</context>
</line>
<line>
<line_number>82</line_number>
<line_content>@st.cache_resource(show_spinner=False)</line_content>
<context>
, show_caches=False)</context>
</line>
<line>
<line_number>83</line_number>
<line_content>def get_index(folder_name, file_name):</line_content>
<context>
get_folder(folder)</context>
</line>
<line>
<line_number>85</line_number>
<line_content>Get the index for a given PDF file.</line_content>
<context>
the file index on Windows</context>
</line>
<line>
<line_number>87</line_number>
<line_content>index_name = file_name.replace('.pdf', '.json')</line_content>
<context>
$ python -m json.tool mp_films.json [ { "title": "And Now for Something Completely Different", "year": 1971 }, { "title": "Monty Python and the Holy Grail", "year": 1975 } ]</context>
</line>
<line>
<line_number>88</line_number>
<line_content>index = None</line_content>
<context>
if self.index == 0:</context>
</line>
<line>
<line_number>90</line_number>
<line_content>if s3.file_exists(folder_name, index_name):</line_content>
<context>
if filename and os.path.isfile(filename):</context>
</line>
<line>
<line_number>91</line_number>
<line_content>logging.info('Index found, loading index...')</line_content>
<context>
logging.info('Doing something')</context>
</line>
<line>
<line_number>92</line_number>
<line_content>with tempfile.TemporaryDirectory() as tmp_dir:</line_content>
<context>
with tempfile.TemporaryDirectory() as tmpdirname:</context>
</line>
<line>
<line_number>93</line_number>
<line_content>tmp_path = f'{tmp_dir}/{index_name}'</line_content>
<context>
directory /tmp/</context>
</line>
<line>
<line_number>94</line_number>
<line_content>s3.download_file(f'{folder_name}/{index_name}', tmp_path)</line_content>
<context>
Changed in version 3.7: Accepts a *path-like object* for *filename* and *extract_dir*.</context>
</line>
<line>
<line_number>95</line_number>
<line_content>index = GPTSimpleVectorIndex.load_from_disk(tmp_path)</line_content>
<context>
"__index__()" method). In future version they will be errors.</context>
</line>
<line>
<line_number>98</line_number>
<line_content>logging.info('Index not found, generating index...')</line_content>
<context>
logging.info('Doing something')</context>
</line>
<line>
<line_number>99</line_number>
<line_content>with tempfile.NamedTemporaryFile('wb') as f_src:</line_content>
<context>
tempfile.NamedTemporaryFile(mode='w+b', buffering=- 1, encoding=None, newline=None, suffix=None, prefix=None, dir=None, delete=True, *, errors=None)</context>
</line>
<line>
<line_number>100</line_number>
<line_content>logging.info(f'{file_name} downloaded')</line_content>
<context>
"filename": "app.log",</context>
</line>
<line>
<line_number>101</line_number>
<line_content>s3.download_file(f'{folder_name}/{file_name}', f_src.name)</line_content>
<context>
Changed in version 3.7: Accepts a *path-like object* for *filename* and *extract_dir*.</context>
</line>
<line>
<line_number>103</line_number>
<line_content>with open(f_src.name, 'rb') as f:</line_content>
<context>
f = open("myfile.jpg", "rb")</context>
</line>
<line>
<line_number>104</line_number>
<line_content>index = create_index(f, folder_name, file_name)</line_content>
<context>
"__index__": "1"</context>
</line>
<line>
<line_number>106</line_number>
<line_content>return index</line_content>
<context>
index</context>
</line>
<line>
<line_number>109</line_number>
<line_content>def query_gpt(chosen_class, chosen_pdf, query):</line_content>
<context>
get_selection()</context>
</line>
<line>
<line_number>111</line_number>
<line_content>if not os.getenv('OPENAI_API_KEY'):</line_content>
<context>
os.getenv(key, default=None)</context>
</line>
<line>
<line_number>112</line_number>
<line_content>st.error('Enter your OpenAI API key in the sidebar.')</line_content>
<context>
problematic API and is now deprecated.</context>
</line>
<line>
<line_number>115</line_number>
<line_content># LLM Predictor (gpt-3.5-turbo)</line_content>
<context>
gh-91583: Fix regression in the code generated by Argument Clinic</context>
</line>
<line>
<line_number>116</line_number>
<line_content>llm_predictor = LLMPredictor(</line_content>
<context>
Changed in version 3.2: Support for ""%lld"" and ""%llu"" added.</context>
</line>
<line>
<line_number>117</line_number>
<line_content>llm=ChatOpenAI(</line_content>
<context>
m module</context>
</line>
<line>
<line_number>118</line_number>
<line_content>temperature=0,</line_content>
<context>
temp;</context>
</line>
<line>
<line_number>119</line_number>
<line_content>model_name='gpt-3.5-turbo',</line_content>
<context>
# The create_model decorator is defined by a library. @typing.dataclass_transform() def create_model(cls: Type[T]) -> Type[T]: cls.__init__ = ... cls.__eq__ = ... cls.__ne__ = ... return cls</context>
</line>
<line>
<line_number>123</line_number>
<line_content>index = get_index(chosen_class, chosen_pdf)</line_content>
<context>
get_selection()</context>
</line>
<line>
<line_number>124</line_number>
<line_content>response = index.query(query, llm_predictor=llm_predictor)</line_content>
<context>
>>> res = cur.execute("SELECT score FROM movie") >>> res.fetchall() [(8.2,), (7.5,)]</context>
</line>
<line>
<line_number>126</line_number>
<line_content># logging.info(response.get_formatted_sources())</line_content>
<context>
logging.Formatter.__init__(fmt=None, datefmt=None, style='%')</context>
</line>
<line>
<line_number>128</line_number>
<line_content>return response</line_content>
<context>
return</context>
</line>
<line>
<line_number>131</line_number>
<line_content>@st.cache_resource</line_content>
<context>
_cache = {}</context>
</line>
<line>
<line_number>132</line_number>
<line_content>def create_tool(_index, chosen_pdf):</line_content>
<context>
Py_mod_create</context>
</line>
<line>
<line_number>135</line_number>
<line_content>name=f'{chosen_pdf} index',</line_content>
<context>
get_selection()</context>
</line>
<line>
<line_number>136</line_number>
<line_content>func=lambda q: str(_index.query(q)),</line_content>
<context>
lambda_expr ::= "lambda" [parameter_list] ":" expression</context>
</line>
<line>
<line_number>137</line_number>
<line_content>description='Useful to answering questions about the given file',</line_content>
<context>
pathname* is the pathname of the file found, and *description* is</context>
</line>
<line>
<line_number>138</line_number>
<line_content>return_direct=True,</line_content>
<context>
Py_RETURN_TRUE</context>
</line>
<line>
<line_number>142</line_number>
<line_content>return tools</line_content>
<context>
return suite</context>
</line>
<line>
<line_number>145</line_number>
<line_content>@st.cache_resource</line_content>
<context>
_cache = {}</context>
</line>
<line>
<line_number>146</line_number>
<line_content>def create_agent(chosen_class, chosen_pdf):</line_content>
<context>
def make_new_user(user_class: type[User])</context>
</line>
<line>
<line_number>147</line_number>
<line_content>memory = ConversationBufferMemory(memory_key='chat_history')</line_content>
<context>
async_chat.collect_incoming_data(data)</context>
</line>
<line>
<line_number>148</line_number>
<line_content>llm = OpenAI(temperature=0, model_name='gpt-3.5-turbo')</line_content>
<context>
def current_temperature(self): "Latest hourly observation" # Do not cache this because old results # can be out of date.</context>
</line>
<line>
<line_number>150</line_number>
<line_content>index = get_index(chosen_class, chosen_pdf)</line_content>
<context>
get_selection()</context>
</line>
<line>
<line_number>151</line_number>
<line_content>tools = create_tool(index, chosen_pdf)</line_content>
<context>
"pickletools" --- Tools for pickle developers</context>
</line>
<line>
<line_number>153</line_number>
<line_content>agent = initialize_agent(</line_content>
<context>
# this is the new initializer: def __set_name__(self, owner, name): self.name = name</context>
</line>
<line>
<line_number>154</line_number>
<line_content>tools, llm, agent='conversational-react-description', memory=memory</line_content>
<context>
agent', 'Mozilla/5.0')]</context>
</line>
<line>
<line_number>157</line_number>
<line_content>return agent</line_content>
<context>
Return</context>
</line>
<line>
<line_number>160</line_number>
<line_content>def query_gpt_memory(chosen_class, chosen_pdf, query):</line_content>
<context>
objects. The memory is taken from the Python private heap.</context>
</line>
<line>
<line_number>162</line_number>
<line_content>agent = create_agent(chosen_class, chosen_pdf)</line_content>
<context>
Return a new "Document" object (the root of the DOM), with a child "Element" object having the given *namespaceUri* and *qualifiedName*. The *doctype* must be a "DocumentType" object created by "createDocumentType()", or "None". In the Python DOM API, the first two arguments can also be "None" in order to indicate that no "Element" child is to be created.</context>
</line>
<line>
<line_number>166</line_number>
<line_content>res = agent.run(input=query)</line_content>
<context>
>>> data = res.read()</context>
</line>
<line>
<line_number>167</line_number>
<line_content>except Exception as e:</line_content>
<context>
except Exception1:</context>
</line>
<line>
<line_number>168</line_number>
<line_content>logging.error(e)</line_content>
<context>
logging.error(msg,</context>
</line>
<line>
<line_number>169</line_number>
<line_content>res = 'Something went wrong... Please try again.'</line_content>
<context>
res = None</context>
</line>
<line>
<line_number>171</line_number>
<line_content>st.session_state.memory = agent.memory.buffer</line_content>
<context>
"session"</context>
</line>
<line>
<line_number>173</line_number>
<line_content>return res</line_content>
<context>
res = None</context>
</line>
<line>
<line_number>179</line_number>
<line_content>@st.cache_data</line_content>
<context>
@lru_cache</context>
</line>
<line>
<line_number>180</line_number>
<line_content>def show_pdf(folder_name, file_name):</line_content>
<context>
filename will be inferred from the library name. *output_dir*</context>
</line>
<line>
<line_number>182</line_number>
<line_content>with tempfile.NamedTemporaryFile('wb') as f_src:</line_content>
<context>
tempfile.NamedTemporaryFile(mode='w+b', buffering=- 1, encoding=None, newline=None, suffix=None, prefix=None, dir=None, delete=True, *, errors=None)</context>
</line>
<line>
<line_number>183</line_number>
<line_content>logging.info(f'Downloading {file_name}...')</line_content>
<context>
logging.info('Doing something')</context>
</line>
<line>
<line_number>184</line_number>
<line_content>s3.download_file(f'{folder_name}/{file_name}', f_src.name)</line_content>
<context>
Changed in version 3.7: Accepts a *path-like object* for *filename* and *extract_dir*.</context>
</line>
<line>
<line_number>186</line_number>
<line_content>with open(f_src.name, 'rb') as f:</line_content>
<context>
f = open("myfile.jpg", "rb")</context>
</line>
<line>
<line_number>187</line_number>
<line_content>base64_pdf = base64.b64encode(f.read()).decode('utf-8')</line_content>
<context>
base64.decode(input, output)</context>
</line>
<line>
<line_number>189</line_number>
<line_content>pdf_display = f'''</line_content>
<context>
pdf(x) =  -------------------------------------</context>
</line>
<line>
<line_number>191</line_number>
<line_content>src='data:application/pdf;base64,{base64_pdf}'</line_content>
<context>
"base64.Error" in these cases.</context>
</line>
<line>
<line_number>192</line_number>
<line_content>width='100%' height='1000'</line_content>
<context>
width=width</context>
</line>
<line>
<line_number>193</line_number>
<line_content>type='application/pdf'</line_content>
<context>
DocumentType.name</context>
</line>
<line>
<line_number>194</line_number>
<line_content>style='min-width: 400px;'</line_content>
<context>
minwidth: width</context>
</line>
<line>
<line_number>199</line_number>
<line_content>st.markdown(pdf_display, unsafe_allow_html=True)</line_content>
<context>
<!DOCTYPE html PUBLIC "
</context>
</line>
</file_context>
</file>
</files>