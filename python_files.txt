<files>
<file>
<file_path>app/01_‚ùì_Ask.py</file_path>
<file_content>
import streamlit as st
from components.sidebar import sidebar
from s3 import S3
from utils import query_gpt, query_gpt_memory, show_pdf

st.set_page_config(
    page_title="ClassGPT",
    page_icon="ü§ñ",
    layout="wide",
    initial_sidebar_state="expanded",
    menu_items={
        "Get Help": "https://twitter.com/benthecoder1",
        "Report a bug": "https://github.com/benthecoder/ClassGPT/issues",
        "About": "ClassGPT is a chatbot that answers questions about your pdf files",
    },
)

# Session states
# --------------
if "chosen_class" not in st.session_state:
    st.session_state.chosen_class = "--"

if "chosen_pdf" not in st.session_state:
    st.session_state.chosen_pdf = "--"

if "memory" not in st.session_state:
    st.session_state.memory = ""


sidebar()

st.header("ClassGPT: ChatGPT for your lectures slides")

bucket_name = "classgpt"
s3 = S3(bucket_name)

all_classes = s3.list_files()

chosen_class = st.selectbox(
    "Select a class", list(all_classes.keys()) + ["--"], index=len(all_classes)
)

st.session_state.chosen_class = chosen_class

if st.session_state.chosen_class != "--":
    all_pdfs = all_classes[chosen_class]

    chosen_pdf = st.selectbox(
        "Select a PDF file", all_pdfs + ["--"], index=len(all_pdfs)
    )

    st.session_state.chosen_pdf = chosen_pdf

    if st.session_state.chosen_pdf != "--":
        col1, col2 = st.columns(2)

        with col1:
            st.subheader("Ask a question")
            st.markdown(
                """
                Here are some prompts:
                - `What is the main idea of this lecture in simple terms?`
                - `Summarize the main points of slide 5`
                - `Provide 5 practice questions on this lecture with answers`
                """
            )
            query = st.text_area("Enter your question", max_chars=200)

            if st.button("Ask"):
                if query == "":
                    st.error("Please enter a question")
                with st.spinner("Generating answer..."):
                    # res = query_gpt_memory(chosen_class, chosen_pdf, query)
                    res = query_gpt(chosen_class, chosen_pdf, query)
                    st.markdown(res)

                    # with st.expander("Memory"):
                    #      st.write(st.session_state.memory.replace("\n", "\n\n"))

        with col2:
            show_pdf(chosen_class, chosen_pdf)

</file_content>
<file_context>
<line>
<line_number>0</line_number>
<line_content>import streamlit as st</line_content>
<context>
StreamReader</context>
</line>
<line>
<line_number>1</line_number>
<line_content>from components.sidebar import sidebar</line_content>
<context>
"foo" imports "bar"</context>
</line>
<line>
<line_number>2</line_number>
<line_content>from s3 import S3</line_content>
<context>
>>> import custom3</context>
</line>
<line>
<line_number>3</line_number>
<line_content>from utils import query_gpt, query_gpt_memory, show_pdf</line_content>
<context>
objects. The memory is taken from the Python private heap.</context>
</line>
<line>
<line_number>5</line_number>
<line_content>st.set_page_config(</line_content>
<context>
config_str, const char</context>
</line>
<line>
<line_number>6</line_number>
<line_content>page_title='ClassGPT',</line_content>
<context>
defining_class,</context>
</line>
<line>
<line_number>7</line_number>
<line_content>page_icon='ü§ñ',</line_content>
<context>
python example.py https://example.com/path/page.html</context>
</line>
<line>
<line_number>8</line_number>
<line_content>layout='wide',</line_content>
<context>
width</context>
</line>
<line>
<line_number>9</line_number>
<line_content>initial_sidebar_state='expanded',</line_content>
<context>
Empty globals for "bar" are created</context>
</line>
<line>
<line_number>10</line_number>
<line_content>menu_items={</line_content>
<context>
['foo', 'item']</context>
</line>
<line>
<line_number>11</line_number>
<line_content>'Get Help': 'https://twitter.com/benthecoder1',</line_content>
<context>
"'help'" - This prints a complete help message for all the options</context>
</line>
<line>
<line_number>12</line_number>
<line_content>'Report a bug': 'https://github.com/benthecoder/ClassGPT/issues',</line_content>
<context>
Fixes code broken from the removal of some members in the "types" module.</context>
</line>
<line>
<line_number>13</line_number>
<line_content>'About': 'ClassGPT is a chatbot that answers questions about your pdf files',</line_content>
<context>
The TextFile class</context>
</line>
<line>
<line_number>19</line_number>
<line_content>if 'chosen_class' not in st.session_state:</line_content>
<context>
return __class__</context>
</line>
<line>
<line_number>20</line_number>
<line_content>st.session_state.chosen_class = '--'</line_content>
<context>
class LoggedAccess:</context>
</line>
<line>
<line_number>22</line_number>
<line_content>if 'chosen_pdf' not in st.session_state:</line_content>
<context>
if (_Pickler_ClearBuffer(self) < 0) { return NULL; }</context>
</line>
<line>
<line_number>23</line_number>
<line_content>st.session_state.chosen_pdf = '--'</line_content>
<context>
option string is present but not followed by a command-line</context>
</line>
<line>
<line_number>25</line_number>
<line_content>if 'memory' not in st.session_state:</line_content>
<context>
If the request fails, "PyMem_Realloc()" returns "NULL" and *p* remains a valid pointer to the previous memory area.</context>
</line>
<line>
<line_number>26</line_number>
<line_content>st.session_state.memory = ''</line_content>
<context>
If the request fails, "PyMem_Realloc()" returns "NULL" and *p* remains a valid pointer to the previous memory area.</context>
</line>
<line>
<line_number>31</line_number>
<line_content>st.header('ClassGPT: ChatGPT for your lectures slides')</line_content>
<context>
class Message:</context>
</line>
<line>
<line_number>33</line_number>
<line_content>bucket_name = 'classgpt'</line_content>
<context>
defining_class,</context>
</line>
<line>
<line_number>34</line_number>
<line_content>s3 = S3(bucket_name)</line_content>
<context>
s2)</context>
</line>
<line>
<line_number>36</line_number>
<line_content>all_classes = s3.list_files()</line_content>
<context>
Returns the name of the object files for the given source files. *source_filenames* should be a list of filenames.</context>
</line>
<line>
<line_number>38</line_number>
<line_content>chosen_class = st.selectbox(</line_content>
<context>
class _pickle.Pickler "PicklerObject</context>
</line>
<line>
<line_number>39</line_number>
<line_content>'Select a class', list(all_classes.keys()) + ['--'], index=len(all_classes)</line_content>
<context>
How do I get a list of all instances of a given class? ------------------------------------------------------</context>
</line>
<line>
<line_number>42</line_number>
<line_content>st.session_state.chosen_class = chosen_class</line_content>
<context>
class LoggedAccess:</context>
</line>
<line>
<line_number>44</line_number>
<line_content>if st.session_state.chosen_class != '--':</line_content>
<context>
>>> class Color(Flag): ...     BLACK = 0 ...     RED = auto() ...     BLUE = auto() ...     GREEN = auto() ... >>> Color.BLACK <Color.BLACK: 0> >>> bool(Color.BLACK) False</context>
</line>
<line>
<line_number>45</line_number>
<line_content>all_pdfs = all_classes[chosen_class]</line_content>
<context>
subclass_of*</context>
</line>
<line>
<line_number>47</line_number>
<line_content>chosen_pdf = st.selectbox(</line_content>
<context>
Use "select".</context>
</line>
<line>
<line_number>48</line_number>
<line_content>'Select a PDF file', all_pdfs + ['--'], index=len(all_pdfs)</line_content>
<context>
for file in very_long_list_of_files:</context>
</line>
<line>
<line_number>51</line_number>
<line_content>st.session_state.chosen_pdf = chosen_pdf</line_content>
<context>
Note that inclusion in the *choices* sequence is checked after any type conversions have been performed, so the type of the objects in the *choices* sequence should match the type specified:</context>
</line>
<line>
<line_number>53</line_number>
<line_content>if st.session_state.chosen_pdf != '--':</line_content>
<context>
command line, if the option string is encountered with no command-</context>
</line>
<line>
<line_number>54</line_number>
<line_content>col1, col2 = st.columns(2)</line_content>
<context>
[2] Columns:</context>
</line>
<line>
<line_number>56</line_number>
<line_content>with col1:</line_content>
<context>
with a:</context>
</line>
<line>
<line_number>57</line_number>
<line_content>st.subheader('Ask a question')</line_content>
<context>
Headers</context>
</line>
<line>
<line_number>58</line_number>
<line_content>st.markdown(</line_content>
<context>
formatters:</context>
</line>
<line>
<line_number>60</line_number>
<line_content>Here are some prompts:</line_content>
<context>
readline configuration on interactive prompts.</context>
</line>
<line>
<line_number>61</line_number>
<line_content>- `What is the main idea of this lecture in simple terms?`</line_content>
<context>
Basic concepts</context>
</line>
<line>
<line_number>62</line_number>
<line_content>- `Summarize the main points of slide 5`</line_content>
<context>
To summarize:</context>
</line>
<line>
<line_number>63</line_number>
<line_content>- `Provide 5 practice questions on this lecture with answers`</line_content>
<context>
3. include "test/test</context>
</line>
<line>
<line_number>66</line_number>
<line_content>query = st.text_area('Enter your question', max_chars=200)</line_content>
<context>
Create a new Unicode object. *maxchar* should be the true maximum code point to be placed in the string. As an approximation, it can be rounded up to the nearest value in the sequence 127, 255, 65535, 1114111.</context>
</line>
<line>
<line_number>68</line_number>
<line_content>if st.button('Ask'):</line_content>
<context>
"'?'". One argument will be consumed from the command line if</context>
</line>
<line>
<line_number>69</line_number>
<line_content>if query == '':</line_content>
<context>
if (result ==</context>
</line>
<line>
<line_number>70</line_number>
<line_content>st.error('Please enter a question')</line_content>
<context>
An ERROR message</context>
</line>
<line>
<line_number>71</line_number>
<line_content>with st.spinner('Generating answer...'):</line_content>
<context>
Here's the simplest example of a generator function:</context>
</line>
<line>
<line_number>72</line_number>
<line_content># res = query_gpt_memory(chosen_class, chosen_pdf, query)</line_content>
<context>
objects. The memory is taken from the Python private heap.</context>
</line>
<line>
<line_number>73</line_number>
<line_content>res = query_gpt(chosen_class, chosen_pdf, query)</line_content>
<context>
>>> class Student: ...     def __init__(self, name, grade, age): ...         self.name = name ...         self.grade = grade ...         self.age = age ...     def __repr__(self): ...         return repr((self.name, self.grade, self.age))</context>
</line>
<line>
<line_number>74</line_number>
<line_content>st.markdown(res)</line_content>
<context>
For such REs, specifying the "re.VERBOSE" flag when compiling the regular expression can be helpful, because it allows you to format the regular expression more clearly.</context>
</line>
<line>
<line_number>76</line_number>
<line_content># with st.expander('Memory'):</line_content>
<context>
"U#" ("str" or "None") [const char *, "Py_ssize_t"] Same as "s#".</context>
</line>
<line>
<line_number>77</line_number>
<line_content>#      st.write(st.session_state.memory.replace('\n', '\n\n'))</line_content>
<context>
sys.stderr.write('%s\n' % s)</context>
</line>
<line>
<line_number>79</line_number>
<line_content>with col2:</line_content>
<context>
with a:</context>
</line>
<line>
<line_number>80</line_number>
<line_content>show_pdf(chosen_class, chosen_pdf)</line_content>
<context>
return __class__
</context>
</line>
</file_context>
</file>
<file>
<file_path>app/components/sidebar.py</file_path>
<file_content>
import os

import streamlit as st


def sidebar():
    with st.sidebar:
        st.markdown(
            "## How to use\n"
            "1. Add your files in üìÅ Data page\n"
            "2. Ask a question on the ‚ùì Ask page\n"
        )
        api_key_input = st.text_input(
            "OpenAI API Key",
            type="password",
            placeholder="sk-xxx...",
            help="Get an API key here üëâ https://platform.openai.com/account/api-keys.",
            value="",
        )

        if api_key_input:
            os.environ["OPENAI_API_KEY"] = api_key_input
            st.success("API key set")

        st.markdown(
            """
            ---
            ## About

            ClassGPT lets you ask questions about your class \
                lectures and get accurate answers

            This tool is a work in progress.

            Contributions are welcomed on [GitHub](https://github.com/benthecoder/ClassGPT)

            Made with ‚ô•Ô∏è by [Benedict Neo](https://benneo.super.site/)
            """
        )

</file_content>
<file_context>
<line>
<line_number>2</line_number>
<line_content>import streamlit as st</line_content>
<context>
StreamReader</context>
</line>
<line>
<line_number>5</line_number>
<line_content>def sidebar():</line_content>
<context>
"bar.py":</context>
</line>
<line>
<line_number>6</line_number>
<line_content>with st.sidebar:</line_content>
<context>
>bar);</context>
</line>
<line>
<line_number>7</line_number>
<line_content>st.markdown(</line_content>
<context>
formatters:</context>
</line>
<line>
<line_number>8</line_number>
<line_content>'## How to use\n'</line_content>
<context>
# some code</context>
</line>
<line>
<line_number>9</line_number>
<line_content>'1. Add your files in üìÅ Data page\n'</line_content>
<context>
The "data_files" option can be used to specify additional files needed by the module distribution: configuration files, message catalogs, data files, anything which doesn't fit in the previous categories.</context>
</line>
<line>
<line_number>10</line_number>
<line_content>'2. Ask a question on the ‚ùì Ask page\n'</line_content>
<context>
q" option.</context>
</line>
<line>
<line_number>12</line_number>
<line_content>api_key_input = st.text_input(</line_content>
<context>
Converts "raw_input()" to "input()".</context>
</line>
<line>
<line_number>13</line_number>
<line_content>'OpenAI API Key',</line_content>
<context>
Limited API Caveats</context>
</line>
<line>
<line_number>14</line_number>
<line_content>type='password',</line_content>
<context>
# create a password manager password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()</context>
</line>
<line>
<line_number>15</line_number>
<line_content>placeholder='sk-xxx...',</line_content>
<context>
2. Replace the ASCII section with whatever placeholders you like, but make sure that the data that appears in there after substitution is always ASCII (that way, it will remain unchanged after UTF-8 encoding).</context>
</line>
<line>
<line_number>16</line_number>
<line_content>help='Get an API key here üëâ https://platform.openai.com/account/api-keys.',</line_content>
<context>
self.key = key</context>
</line>
<line>
<line_number>20</line_number>
<line_content>if api_key_input:</line_content>
<context>
if key in self:</context>
</line>
<line>
<line_number>21</line_number>
<line_content>os.environ['OPENAI_API_KEY'] = api_key_input</line_content>
<context>
self.key = key</context>
</line>
<line>
<line_number>22</line_number>
<line_content>st.success('API key set')</line_content>
<context>
On success, return a list of the keys in object *o*. On failure, return "NULL".</context>
</line>
<line>
<line_number>24</line_number>
<line_content>st.markdown(</line_content>
<context>
formatters:</context>
</line>
<line>
<line_number>29</line_number>
<line_content>ClassGPT lets you ask questions about your class \</line_content>
<context>
What is a class?</context>
</line>
<line>
<line_number>30</line_number>
<line_content>lectures and get accurate answers</line_content>
<context>
Classes</context>
</line>
<line>
<line_number>32</line_number>
<line_content>This tool is a work in progress.</line_content>
<context>
Installing the tools</context>
</line>
<line>
<line_number>34</line_number>
<line_content>Contributions are welcomed on [GitHub](https://github.com/benthecoder/ClassGPT)</line_content>
<context>
Version 0.21: Added more references suggested on the tutor mailing list.</context>
</line>
<line>
<line_number>36</line_number>
<line_content>Made with ‚ô•Ô∏è by [Benedict Neo](https://benneo.super.site/)</line_content>
<context>
https://code.activestate.com/recipes/52560/
</context>
</line>
</file_context>
</file>
<file>
<file_path>app/pages/02_üìÅ_Data.py</file_path>
<file_content>
import streamlit as st
from components.sidebar import sidebar
from s3 import S3

sidebar()
bucket_name = "classgpt"
s3 = S3(bucket_name)
all_classes = s3.list_files()

tab1, tab2, tab3 = st.tabs(["Upload data", "Add Class", "Delete"])

with tab1:
    st.subheader("Upload new lectures")

    chosen_class = st.selectbox(
        "Select a class",
        list(all_classes.keys()) + ["--"],
        index=len(all_classes),
    )

    if chosen_class != "--":
        with st.form("upload_pdf"):
            uploaded_files = st.file_uploader(
                "Upload a PDF file", type="pdf", accept_multiple_files=True
            )

            submit_button = st.form_submit_button("Upload")

            if submit_button:
                if len(uploaded_files) == 0:
                    st.error("Please upload at least one file")
                else:
                    with st.spinner(f"Uploading {len(uploaded_files)} files..."):
                        for uploaded_file in uploaded_files:
                            s3.upload_files(
                                uploaded_file, f"{chosen_class}/{uploaded_file.name}"
                            )

                        st.success(f"{len(uploaded_files)} files uploaded")


with tab2:
    st.subheader("Add a new class")

    with st.form("add_class"):
        add_class = st.text_input("Enter a new class name")

        submit_button = st.form_submit_button("Add")

        if submit_button:
            if add_class == "":
                st.error("Please enter a class name")
            else:
                s3.create_folder(add_class)
                st.success(f"Class {add_class} added")

with tab3:
    st.subheader("Delete a class or a PDF file")

    chosen_class = st.selectbox(
        "Select a class to delete",
        list(all_classes.keys()) + ["--"],
        index=len(all_classes),
    )

    if chosen_class != "--":
        all_pdfs = all_classes[chosen_class] + ["all"]

        # Remove empty values
        all_pdfs = [x for x in all_pdfs if x]

        chosen_pdf = st.selectbox(
            "Select a PDF file or choose 'all' to delete the whole class",
            all_pdfs + ["--"],
            index=len(all_pdfs),
        )

        if chosen_pdf != "--":
            submit_button = st.button("Remove")

            if submit_button:
                if chosen_pdf == "all":
                    s3.remove_folder(chosen_class)
                    st.success(f"{chosen_class} removed")
                else:
                    s3.remove_file(chosen_class, chosen_pdf)
                    st.success(f"{chosen_pdf} removed")

</file_content>
<file_context>
<line>
<line_number>0</line_number>
<line_content>import streamlit as st</line_content>
<context>
StreamReader</context>
</line>
<line>
<line_number>1</line_number>
<line_content>from components.sidebar import sidebar</line_content>
<context>
"foo" imports "bar"</context>
</line>
<line>
<line_number>2</line_number>
<line_content>from s3 import S3</line_content>
<context>
>>> import custom3</context>
</line>
<line>
<line_number>5</line_number>
<line_content>bucket_name = 'classgpt'</line_content>
<context>
defining_class,</context>
</line>
<line>
<line_number>6</line_number>
<line_content>s3 = S3(bucket_name)</line_content>
<context>
s2)</context>
</line>
<line>
<line_number>7</line_number>
<line_content>all_classes = s3.list_files()</line_content>
<context>
Returns the name of the object files for the given source files. *source_filenames* should be a list of filenames.</context>
</line>
<line>
<line_number>9</line_number>
<line_content>tab1, tab2, tab3 = st.tabs(['Upload data', 'Add Class', 'Delete'])</line_content>
<context>
How do I keep editors from inserting tabs into my Python source? ================================================================</context>
</line>
<line>
<line_number>11</line_number>
<line_content>with tab1:</line_content>
<context>
Here's an example which shows how you can:</context>
</line>
<line>
<line_number>12</line_number>
<line_content>st.subheader('Upload new lectures')</line_content>
<context>
class ast.Sub</context>
</line>
<line>
<line_number>14</line_number>
<line_content>chosen_class = st.selectbox(</line_content>
<context>
class _pickle.Pickler "PicklerObject</context>
</line>
<line>
<line_number>15</line_number>
<line_content>'Select a class',</line_content>
<context>
What is a class?</context>
</line>
<line>
<line_number>16</line_number>
<line_content>list(all_classes.keys()) + ['--'],</line_content>
<context>
class ast.Dict(keys, values)</context>
</line>
<line>
<line_number>17</line_number>
<line_content>index=len(all_classes),</line_content>
<context>
How do I get a list of all instances of a given class? ------------------------------------------------------</context>
</line>
<line>
<line_number>20</line_number>
<line_content>if chosen_class != '--':</line_content>
<context>
>>> class Color(Flag): ...     BLACK = 0 ...     RED = auto() ...     BLUE = auto() ...     GREEN = auto() ... >>> Color.BLACK <Color.BLACK: 0> >>> bool(Color.BLACK) False</context>
</line>
<line>
<line_number>21</line_number>
<line_content>with st.form('upload_pdf'):</line_content>
<context>
The file upload draft standard entertains the possibility of uploading multiple files from one field (using a recursive *multipart/** encoding). When this occurs, the item will be a dictionary-like "FieldStorage" item. This can be determined by testing its "type" attribute, which should be *multipart/form-data* (or perhaps another MIME type matching *multipart/**). In this case, it can be iterated over recursively just like the top-level form object.</context>
</line>
<line>
<line_number>22</line_number>
<line_content>uploaded_files = st.file_uploader(</line_content>
<context>
"file"</context>
</line>
<line>
<line_number>23</line_number>
<line_content>'Upload a PDF file', type='pdf', accept_multiple_files=True</line_content>
<context>
The file upload draft standard entertains the possibility of uploading multiple files from one field (using a recursive *multipart/** encoding). When this occurs, the item will be a dictionary-like "FieldStorage" item. This can be determined by testing its "type" attribute, which should be *multipart/form-data* (or perhaps another MIME type matching *multipart/**). In this case, it can be iterated over recursively just like the top-level form object.</context>
</line>
<line>
<line_number>26</line_number>
<line_content>submit_button = st.form_submit_button('Upload')</line_content>
<context>
"copy_file()".</context>
</line>
<line>
<line_number>28</line_number>
<line_content>if submit_button:</line_content>
<context>
However, this idiom is unsafe, as it can give wrong results when *on_true* has a false boolean value. Therefore, it is always better to use the "... if ... else ..." form.</context>
</line>
<line>
<line_number>29</line_number>
<line_content>if len(uploaded_files) == 0:</line_content>
<context>
fileitem = form["userfile"] if fileitem.file: # It's an uploaded file; count lines linecount = 0 while True: line = fileitem.file.readline() if not line: break linecount = linecount + 1</context>
</line>
<line>
<line_number>30</line_number>
<line_content>st.error('Please upload at least one file')</line_content>
<context>
file* must be a regular file object open in binary mode.</context>
</line>
<line>
<line_number>32</line_number>
<line_content>with st.spinner(f'Uploading {len(uploaded_files)} files...'):</line_content>
<context>
for file in very_long_list_of_files:</context>
</line>
<line>
<line_number>33</line_number>
<line_content>for uploaded_file in uploaded_files:</line_content>
<context>
"file"</context>
</line>
<line>
<line_number>34</line_number>
<line_content>s3.upload_files(</line_content>
<context>
"file": {</context>
</line>
<line>
<line_number>35</line_number>
<line_content>uploaded_file, f'{chosen_class}/{uploaded_file.name}'</line_content>
<context>
Changed in version 3.4: The "__file__" attribute is no longer set on the module.</context>
</line>
<line>
<line_number>38</line_number>
<line_content>st.success(f'{len(uploaded_files)} files uploaded')</line_content>
<context>
"file" *</context>
</line>
<line>
<line_number>41</line_number>
<line_content>with tab2:</line_content>
<context>
which you can use like this:</context>
</line>
<line>
<line_number>42</line_number>
<line_content>st.subheader('Add a new class')</line_content>
<context>
class Sub(Base):</context>
</line>
<line>
<line_number>44</line_number>
<line_content>with st.form('add_class'):</line_content>
<context>
defining_class,</context>
</line>
<line>
<line_number>45</line_number>
<line_content>add_class = st.text_input('Enter a new class name')</line_content>
<context>
/*[clinic input] module.class.new_function [as c_basename] = module.class.existing_function</context>
</line>
<line>
<line_number>47</line_number>
<line_content>submit_button = st.form_submit_button('Add')</line_content>
<context>
The add_argument() method</context>
</line>
<line>
<line_number>49</line_number>
<line_content>if submit_button:</line_content>
<context>
However, this idiom is unsafe, as it can give wrong results when *on_true* has a false boolean value. Therefore, it is always better to use the "... if ... else ..." form.</context>
</line>
<line>
<line_number>50</line_number>
<line_content>if add_class == '':</line_content>
<context>
defining_class,</context>
</line>
<line>
<line_number>51</line_number>
<line_content>st.error('Please enter a class name')</line_content>
<context>
"name" is a raw string for the class name</context>
</line>
<line>
<line_number>53</line_number>
<line_content>s3.create_folder(add_class)</line_content>
<context>
class Directory:</context>
</line>
<line>
<line_number>54</line_number>
<line_content>st.success(f'Class {add_class} added')</line_content>
<context>
return __class__</context>
</line>
<line>
<line_number>56</line_number>
<line_content>with tab3:</line_content>
<context>
which you can use like this:</context>
</line>
<line>
<line_number>57</line_number>
<line_content>st.subheader('Delete a class or a PDF file')</line_content>
<context>
How do I delete a file? (And other file questions...) -----------------------------------------------------</context>
</line>
<line>
<line_number>59</line_number>
<line_content>chosen_class = st.selectbox(</line_content>
<context>
class _pickle.Pickler "PicklerObject</context>
</line>
<line>
<line_number>60</line_number>
<line_content>'Select a class to delete',</line_content>
<context>
My class defines __del__ but it is not called when I delete the object. -----------------------------------------------------------------------</context>
</line>
<line>
<line_number>61</line_number>
<line_content>list(all_classes.keys()) + ['--'],</line_content>
<context>
class ast.Dict(keys, values)</context>
</line>
<line>
<line_number>62</line_number>
<line_content>index=len(all_classes),</line_content>
<context>
How do I get a list of all instances of a given class? ------------------------------------------------------</context>
</line>
<line>
<line_number>65</line_number>
<line_content>if chosen_class != '--':</line_content>
<context>
>>> class Color(Flag): ...     BLACK = 0 ...     RED = auto() ...     BLUE = auto() ...     GREEN = auto() ... >>> Color.BLACK <Color.BLACK: 0> >>> bool(Color.BLACK) False</context>
</line>
<line>
<line_number>66</line_number>
<line_content>all_pdfs = all_classes[chosen_class] + ['all']</line_content>
<context>
How do I get a list of all instances of a given class? ------------------------------------------------------</context>
</line>
<line>
<line_number>68</line_number>
<line_content># Remove empty values</line_content>
<context>
Omitting values</context>
</line>
<line>
<line_number>69</line_number>
<line_content>all_pdfs = [x for x in all_pdfs if x]</line_content>
<context>
The "any(iter)" and "all(iter)" built-ins look at the truth values of an iterable's contents. "any()" returns "True" if any element in the iterable is a true value, and "all()" returns "True" if all of the elements are true values:</context>
</line>
<line>
<line_number>71</line_number>
<line_content>chosen_pdf = st.selectbox(</line_content>
<context>
Use "select".</context>
</line>
<line>
<line_number>72</line_number>
<line_content>'Select a PDF file or choose 'all' to delete the whole class',</line_content>
<context>
How do I delete a file? (And other file questions...) -----------------------------------------------------</context>
</line>
<line>
<line_number>73</line_number>
<line_content>all_pdfs + ['--'],</line_content>
<context>
>>> print(ast.dump(ast.parse('a,</context>
</line>
<line>
<line_number>74</line_number>
<line_content>index=len(all_pdfs),</line_content>
<context>
>>> print(len(s))</context>
</line>
<line>
<line_number>77</line_number>
<line_content>if chosen_pdf != '--':</line_content>
<context>
You can select only certain elements by adding an ""if"" condition:</context>
</line>
<line>
<line_number>78</line_number>
<line_content>submit_button = st.button('Remove')</line_content>
<context>
self.clear_button.clicked.connect(self.clear_display)</context>
</line>
<line>
<line_number>80</line_number>
<line_content>if submit_button:</line_content>
<context>
However, this idiom is unsafe, as it can give wrong results when *on_true* has a false boolean value. Therefore, it is always better to use the "... if ... else ..." form.</context>
</line>
<line>
<line_number>81</line_number>
<line_content>if chosen_pdf == 'all':</line_content>
<context>
You can select only certain elements by adding an ""if"" condition:</context>
</line>
<line>
<line_number>82</line_number>
<line_content>s3.remove_folder(chosen_class)</line_content>
<context>
distutils.dir_util.remove_tree(directory[, verbose=0, dry_run=0])</context>
</line>
<line>
<line_number>83</line_number>
<line_content>st.success(f'{chosen_class} removed')</line_content>
<context>
return __class__</context>
</line>
<line>
<line_number>85</line_number>
<line_content>s3.remove_file(chosen_class, chosen_pdf)</line_content>
<context>
with tempfile.NamedTemporaryFile(delete=False) as tmp_file:</context>
</line>
<line>
<line_number>86</line_number>
<line_content>st.success(f'{chosen_pdf} removed')</line_content>
<context>
loop.remove_reader(fd)
</context>
</line>
</file_context>
</file>
<file>
<file_path>app/s3.py</file_path>
<file_content>
from collections import defaultdict

import boto3
import botocore


class S3:
    """
    Class for interacting with S3

    Args:
        bucket_name (str): Name of the S3 bucket

    Attributes:
        bucket_name (str): Name of the S3 bucket
        s3 (boto3.resource): S3 resource
        bucket (boto3.Bucket): S3 bucket

    Methods:
        list_folders: List all folders in the S3 bucket
        list_files: List all files in the S3 bucket
        folder_exists: Check if a folder exists in the S3 bucket
        file_exists: Check if a file exists in the S3 bucket
        create_folder: Create a folder in the S3 bucket
        upload_files: Upload a file to the S3 bucket
        remove_folder: Remove a folder from the S3 bucket
        remove_file: Remove a file from the S3 bucket
    """

    def __init__(self, bucket_name):
        self.bucket_name = bucket_name
        self.s3 = boto3.resource("s3")
        self.bucket = self.s3.Bucket(bucket_name)

    def list_folders(self):
        folders = set()
        for obj in self.bucket.objects.filter():
            folders.add(obj.key.split("/")[0])

        return folders

    def list_files(self):
        classes = defaultdict(list)

        # loop through only the parent directory
        for obj in self.bucket.objects.filter():
            cname, fname = obj.key.split("/")
            if not fname.endswith(".json"):
                classes[cname].append(fname)

        return classes

    def folder_exists(self, folder_name):
        for _ in self.bucket.objects.filter(Prefix=f"{folder_name}/"):
            return True
        return False

    def file_exists(self, folder_name, file_name):
        try:
            self.s3.Object(self.bucket_name, f"{folder_name}/{file_name}").load()
            return True
        except botocore.exceptions.ClientError as e:
            if e.response["Error"]["Code"] == "404":
                return False
            else:
                raise

    def create_folder(self, folder_name):
        if not self.folder_exists(folder_name):
            self.bucket.put_object(Key=f"{folder_name}/")

    def upload_files(self, file_obj, file_path):
        self.bucket.upload_fileobj(file_obj, file_path)

    def remove_folder(self, folder_name):
        if self.folder_exists(folder_name):
            for key in self.bucket.objects.filter(Prefix=f"{folder_name}/"):
                key.delete()

    def remove_file(self, folder_name, file_name):
        if self.folder_exists(folder_name):
            self.bucket.objects.filter(Prefix=f"{folder_name}/{file_name}").delete(
                Delete={"Objects": [{"Key": f"{folder_name}/{file_name}"}]}
            )

    def download_file(self, from_file_path, to_file_path):
        self.bucket.download_file(from_file_path, to_file_path)

</file_content>
<file_context>
<line>
<line_number>0</line_number>
<line_content>from collections import defaultdict</line_content>
<context>
newdict = olddict.copy()</context>
</line>
<line>
<line_number>2</line_number>
<line_content>import boto3</line_content>
<context>
>>> import custom3</context>
</line>
<line>
<line_number>3</line_number>
<line_content>import botocore</line_content>
<context>
import</context>
</line>
<line>
<line_number>8</line_number>
<line_content>Class for interacting with S3</line_content>
<context>
Protocol classes can implement the following **callback methods**:</context>
</line>
<line>
<line_number>11</line_number>
<line_content>bucket_name (str): Name of the S3 bucket</line_content>
<context>
print_assign = lambda name, value: name + '=' + str(value)</context>
</line>
<line>
<line_number>13</line_number>
<line_content>Attributes:</line_content>
<context>
Attributes for the character.</context>
</line>
<line>
<line_number>14</line_number>
<line_content>bucket_name (str): Name of the S3 bucket</line_content>
<context>
print_assign = lambda name, value: name + '=' + str(value)</context>
</line>
<line>
<line_number>15</line_number>
<line_content>s3 (boto3.resource): S3 resource</line_content>
<context>
Resources limitations</context>
</line>
<line>
<line_number>16</line_number>
<line_content>bucket (boto3.Bucket): S3 bucket</line_content>
<context>
s2)</context>
</line>
<line>
<line_number>19</line_number>
<line_content>list_folders: List all folders in the S3 bucket</line_content>
<context>
include_dirs*, if given, must be a list of strings, the</context>
</line>
<line>
<line_number>20</line_number>
<line_content>list_files: List all files in the S3 bucket</line_content>
<context>
for file in very_long_list_of_files:</context>
</line>
<line>
<line_number>21</line_number>
<line_content>folder_exists: Check if a folder exists in the S3 bucket</line_content>
<context>
If the folder cannot be retrieved, "OSError" is raised.</context>
</line>
<line>
<line_number>22</line_number>
<line_content>file_exists: Check if a file exists in the S3 bucket</line_content>
<context>
"file": {</context>
</line>
<line>
<line_number>23</line_number>
<line_content>create_folder: Create a folder in the S3 bucket</line_content>
<context>
directory_created(path)</context>
</line>
<line>
<line_number>24</line_number>
<line_content>upload_files: Upload a file to the S3 bucket</line_content>
<context>
The file upload draft standard entertains the possibility of uploading multiple files from one field (using a recursive *multipart/** encoding). When this occurs, the item will be a dictionary-like "FieldStorage" item. This can be determined by testing its "type" attribute, which should be *multipart/form-data* (or perhaps another MIME type matching *multipart/**). In this case, it can be iterated over recursively just like the top-level form object.</context>
</line>
<line>
<line_number>25</line_number>
<line_content>remove_folder: Remove a folder from the S3 bucket</line_content>
<context>
>>> s = Directory('songs') >>> g = Directory('games') >>> s.size                              # The songs directory has twenty files 20 >>> g.size                              # The games directory has three files 3 >>> os.remove('games/chess')            # Delete a game >>> g.size                              # File count is automatically updated 2</context>
</line>
<line>
<line_number>26</line_number>
<line_content>remove_file: Remove a file from the S3 bucket</line_content>
<context>
How do I delete a file? (And other file questions...) -----------------------------------------------------</context>
</line>
<line>
<line_number>29</line_number>
<line_content>def __init__(self, bucket_name):</line_content>
<context>
def __init__(self,</context>
</line>
<line>
<line_number>30</line_number>
<line_content>self.bucket_name = bucket_name</line_content>
<context>
self._name = name</context>
</line>
<line>
<line_number>31</line_number>
<line_content>self.s3 = boto3.resource('s3')</line_content>
<context>
Once you have fully translated your code to be compatible with Python 3, you will want to make sure your code doesn't regress and stop working under Python 3. This is especially true if you have a dependency which is blocking you from actually running under Python 3 at the moment.</context>
</line>
<line>
<line_number>32</line_number>
<line_content>self.bucket = self.s3.Bucket(bucket_name)</line_content>
<context>
def __hash__(self):</context>
</line>
<line>
<line_number>34</line_number>
<line_content>def list_folders(self):</line_content>
<context>
$ python listdir</context>
</line>
<line>
<line_number>35</line_number>
<line_content>folders = set()</line_content>
<context>
set_library_dirs(dirs)</context>
</line>
<line>
<line_number>36</line_number>
<line_content>for obj in self.bucket.objects.filter():</line_content>
<context>
Filter Objects</context>
</line>
<line>
<line_number>37</line_number>
<line_content>folders.add(obj.key.split('/')[0])</line_content>
<context>
glob.glob(os.path.join('mydir', 'subdir', '</context>
</line>
<line>
<line_number>39</line_number>
<line_content>return folders</line_content>
<context>
Files and Directories</context>
</line>
<line>
<line_number>41</line_number>
<line_content>def list_files(self):</line_content>
<context>
self.the_list = the_list</context>
</line>
<line>
<line_number>42</line_number>
<line_content>classes = defaultdict(list)</line_content>
<context>
class Dict(dict):</context>
</line>
<line>
<line_number>44</line_number>
<line_content># loop through only the parent directory</line_content>
<context>
Directory tree operations</context>
</line>
<line>
<line_number>45</line_number>
<line_content>for obj in self.bucket.objects.filter():</line_content>
<context>
Filter Objects</context>
</line>
<line>
<line_number>46</line_number>
<line_content>cname, fname = obj.key.split('/')</line_content>
<context>
result = ''.join(chunks)</context>
</line>
<line>
<line_number>47</line_number>
<line_content>if not fname.endswith('.json'):</line_content>
<context>
{basename_extension} The last '.' and everything after it. If the basename does not contain a period, this will be the empty string.</context>
</line>
<line>
<line_number>48</line_number>
<line_content>classes[cname].append(fname)</line_content>
<context>
append(...)</context>
</line>
<line>
<line_number>50</line_number>
<line_content>return classes</line_content>
<context>
return __class__</context>
</line>
<line>
<line_number>52</line_number>
<line_content>def folder_exists(self, folder_name):</line_content>
<context>
directory_created(path)</context>
</line>
<line>
<line_number>53</line_number>
<line_content>for _ in self.bucket.objects.filter(Prefix=f'{folder_name}/'):</line_content>
<context>
object_filenames(source_filenames[, strip_dir=0, output_dir=''])</context>
</line>
<line>
<line_number>54</line_number>
<line_content>return True</line_content>
<context>
return True</context>
</line>
<line>
<line_number>55</line_number>
<line_content>return False</line_content>
<context>
return True</context>
</line>
<line>
<line_number>57</line_number>
<line_content>def file_exists(self, folder_name, file_name):</line_content>
<context>
If "run_filename" is set and is a directory which contains a</context>
</line>
<line>
<line_number>59</line_number>
<line_content>self.s3.Object(self.bucket_name, f'{folder_name}/{file_name}').load()</line_content>
<context>
shared_object_filename(basename[, strip_dir=0, output_dir=''])</context>
</line>
<line>
<line_number>60</line_number>
<line_content>return True</line_content>
<context>
return True</context>
</line>
<line>
<line_number>61</line_number>
<line_content>except botocore.exceptions.ClientError as e:</line_content>
<context>
This exception is a subclass of "EOFError".</context>
</line>
<line>
<line_number>62</line_number>
<line_content>if e.response['Error']['Code'] == '404':</line_content>
<context>
returned if there was an error.</context>
</line>
<line>
<line_number>63</line_number>
<line_content>return False</line_content>
<context>
return True</context>
</line>
<line>
<line_number>67</line_number>
<line_content>def create_folder(self, folder_name):</line_content>
<context>
directory_created(path)</context>
</line>
<line>
<line_number>68</line_number>
<line_content>if not self.folder_exists(folder_name):</line_content>
<context>
If the folder cannot be retrieved, "OSError" is raised.</context>
</line>
<line>
<line_number>69</line_number>
<line_content>self.bucket.put_object(Key=f'{folder_name}/')</line_content>
<context>
shared_object_filename(basename[, strip_dir=0, output_dir=''])</context>
</line>
<line>
<line_number>71</line_number>
<line_content>def upload_files(self, file_obj, file_path):</line_content>
<context>
int Py_file_input</context>
</line>
<line>
<line_number>72</line_number>
<line_content>self.bucket.upload_fileobj(file_obj, file_path)</line_content>
<context>
file as file_obj: object</context>
</line>
<line>
<line_number>74</line_number>
<line_content>def remove_folder(self, folder_name):</line_content>
<context>
distutils.dir_util.remove_tree(directory[, verbose=0, dry_run=0])</context>
</line>
<line>
<line_number>75</line_number>
<line_content>if self.folder_exists(folder_name):</line_content>
<context>
If "run_filename" is set and is a directory which contains a</context>
</line>
<line>
<line_number>76</line_number>
<line_content>for key in self.bucket.objects.filter(Prefix=f'{folder_name}/'):</line_content>
<context>
object_filenames(source_filenames[, strip_dir=0, output_dir=''])</context>
</line>
<line>
<line_number>77</line_number>
<line_content>key.delete()</line_content>
<context>
deleteMe()</context>
</line>
<line>
<line_number>79</line_number>
<line_content>def remove_file(self, folder_name, file_name):</line_content>
<context>
Use "os.remove(filename)" or "os.unlink(filename)"; for documentation, see the "os" module. The two functions are identical; "unlink()" is simply the name of the Unix system call for this function.</context>
</line>
<line>
<line_number>80</line_number>
<line_content>if self.folder_exists(folder_name):</line_content>
<context>
If "run_filename" is set and is a directory which contains a</context>
</line>
<line>
<line_number>81</line_number>
<line_content>self.bucket.objects.filter(Prefix=f'{folder_name}/{file_name}').delete(</line_content>
<context>
object_filenames(source_filenames[, strip_dir=0, output_dir=''])</context>
</line>
<line>
<line_number>82</line_number>
<line_content>Delete={'Objects': [{'Key': f'{folder_name}/{file_name}'}]}</line_content>
<context>
>>> s = Directory('songs') >>> g = Directory('games') >>> s.size                              # The songs directory has twenty files 20 >>> g.size                              # The games directory has three files 3 >>> os.remove('games/chess')            # Delete a game >>> g.size                              # File count is automatically updated 2</context>
</line>
<line>
<line_number>85</line_number>
<line_content>def download_file(self, from_file_path, to_file_path):</line_content>
<context>
"PyFile_FromFd()"</context>
</line>
<line>
<line_number>86</line_number>
<line_content>self.bucket.download_file(from_file_path, to_file_path)</line_content>
<context>
file_created(path)
</context>
</line>
</file_context>
</file>
<file>
<file_path>app/utils.py</file_path>
<file_content>
import base64
import logging
import os
import sys
import tempfile
from io import BytesIO

import openai
import streamlit as st
from dotenv import load_dotenv
from langchain import OpenAI

# langchain
from langchain.agents import Tool, initialize_agent
from langchain.chains.conversation.memory import ConversationBufferMemory
from langchain.chat_models import ChatOpenAI

# llama_index
from llama_index import Document, GPTSimpleVectorIndex, LLMPredictor
from pypdf import PdfReader
from s3 import S3

# set to DEBUG for more verbose logging
logging.basicConfig(stream=sys.stdout, level=logging.INFO)


load_dotenv()
if os.getenv("OPENAI_API_KEY") is None:
    st.error("OpenAI API key not set")
else:
    openai.api_key = os.getenv("OPENAI_API_KEY")


s3 = S3("classgpt")


# ------------------- index creation ------------------- #


def parse_pdf(file: BytesIO):

    pdf = PdfReader(file)
    text_list = []

    # Get the number of pages in the PDF document
    num_pages = len(pdf.pages)

    # Iterate over every page
    for page in range(num_pages):
        # Extract the text from the page
        page_text = pdf.pages[page].extract_text()
        text_list.append(page_text)

    text = "\n".join(text_list)

    return [Document(text)]


def create_index(pdf_obj, folder_name, file_name):
    """
    Create an index for a given PDF file and upload it to S3.
    """
    index_name = file_name.replace(".pdf", ".json")

    logging.info("Generating new index...")
    documents = parse_pdf(pdf_obj)

    logging.info("Creating index...")
    index = GPTSimpleVectorIndex(documents)

    with tempfile.TemporaryDirectory() as tmp_dir:
        tmp_path = f"{tmp_dir}/{index_name}"
        logging.info("Saving index...")
        index.save_to_disk(tmp_path)

        with open(tmp_path, "rb") as f:
            logging.info("Uploading index to s3...")
            s3.upload_files(f, f"{folder_name}/{index_name}")

    return index


@st.cache_resource(show_spinner=False)
def get_index(folder_name, file_name):
    """
    Get the index for a given PDF file.
    """
    index_name = file_name.replace(".pdf", ".json")
    index = None

    if s3.file_exists(folder_name, index_name):
        logging.info("Index found, loading index...")
        with tempfile.TemporaryDirectory() as tmp_dir:
            tmp_path = f"{tmp_dir}/{index_name}"
            s3.download_file(f"{folder_name}/{index_name}", tmp_path)
            index = GPTSimpleVectorIndex.load_from_disk(tmp_path)

    else:
        logging.info("Index not found, generating index...")
        with tempfile.NamedTemporaryFile("wb") as f_src:
            logging.info(f"{file_name} downloaded")
            s3.download_file(f"{folder_name}/{file_name}", f_src.name)

            with open(f_src.name, "rb") as f:
                index = create_index(f, folder_name, file_name)

    return index


def query_gpt(chosen_class, chosen_pdf, query):

    if not os.getenv("OPENAI_API_KEY"):
        st.error("Enter your OpenAI API key in the sidebar.")
        st.stop()

    # LLM Predictor (gpt-3.5-turbo)
    llm_predictor = LLMPredictor(
        llm=ChatOpenAI(
            temperature=0,
            model_name="gpt-3.5-turbo",
        )
    )

    index = get_index(chosen_class, chosen_pdf)
    response = index.query(query, llm_predictor=llm_predictor)

    # logging.info(response.get_formatted_sources())

    return response


@st.cache_resource
def create_tool(_index, chosen_pdf):
    tools = [
        Tool(
            name=f"{chosen_pdf} index",
            func=lambda q: str(_index.query(q)),
            description="Useful to answering questions about the given file",
            return_direct=True,
        ),
    ]

    return tools


@st.cache_resource
def create_agent(chosen_class, chosen_pdf):
    memory = ConversationBufferMemory(memory_key="chat_history")
    llm = OpenAI(temperature=0, model_name="gpt-3.5-turbo")

    index = get_index(chosen_class, chosen_pdf)
    tools = create_tool(index, chosen_pdf)

    agent = initialize_agent(
        tools, llm, agent="conversational-react-description", memory=memory
    )

    return agent


def query_gpt_memory(chosen_class, chosen_pdf, query):

    agent = create_agent(chosen_class, chosen_pdf)
    res = ""

    try:
        res = agent.run(input=query)
    except Exception as e:
        logging.error(e)
        res = "Something went wrong... Please try again."

    st.session_state.memory = agent.memory.buffer

    return res


# ------------------- Render PDF ------------------- #


@st.cache_data
def show_pdf(folder_name, file_name):

    with tempfile.NamedTemporaryFile("wb") as f_src:
        logging.info(f"Downloading {file_name}...")
        s3.download_file(f"{folder_name}/{file_name}", f_src.name)

        with open(f_src.name, "rb") as f:
            base64_pdf = base64.b64encode(f.read()).decode("utf-8")

        pdf_display = f"""
        <iframe
            src="data:application/pdf;base64,{base64_pdf}"
            width="100%" height="1000"
            type="application/pdf"
            style="min-width: 400px;"
        >
        </iframe>
        """

        st.markdown(pdf_display, unsafe_allow_html=True)

</file_content>
<file_context>
<line>
<line_number>0</line_number>
<line_content>import base64</line_content>
<context>
Lib/base64.py</context>
</line>
<line>
<line_number>1</line_number>
<line_content>import logging</line_content>
<context>
import logging</context>
</line>
<line>
<line_number>3</line_number>
<line_content>import sys</line_content>
<context>
import sys</context>
</line>
<line>
<line_number>4</line_number>
<line_content>import tempfile</line_content>
<context>
import tempfile</context>
</line>
<line>
<line_number>5</line_number>
<line_content>from io import BytesIO</line_content>
<context>
>>> import io, sys</context>
</line>
<line>
<line_number>7</line_number>
<line_content>import openai</line_content>
<context>
import</context>
</line>
<line>
<line_number>8</line_number>
<line_content>import streamlit as st</line_content>
<context>
StreamReader</context>
</line>
<line>
<line_number>9</line_number>
<line_content>from dotenv import load_dotenv</line_content>
<context>
Py_GETENV(s)</context>
</line>
<line>
<line_number>10</line_number>
<line_content>from langchain import OpenAI</line_content>
<context>
import atexit</context>
</line>
<line>
<line_number>13</line_number>
<line_content>from langchain.agents import Tool, initialize_agent</line_content>
<context>
Initialize configuration with the Python Configuration.</context>
</line>
<line>
<line_number>14</line_number>
<line_content>from langchain.chains.conversation.memory import ConversationBufferMemory</line_content>
<context>
Speaking logging messages</context>
</line>
<line>
<line_number>15</line_number>
<line_content>from langchain.chat_models import ChatOpenAI</line_content>
<context>
class StructuredMessage: def __init__(self, message, /, **kwargs): self.message = message self.kwargs = kwargs</context>
</line>
<line>
<line_number>18</line_number>
<line_content>from llama_index import Document, GPTSimpleVectorIndex, LLMPredictor</line_content>
<context>
Changed in version 3.8: Use "__index__()" if available.</context>
</line>
<line>
<line_number>19</line_number>
<line_content>from pypdf import PdfReader</line_content>
<context>
"PyFile_FromFd()"</context>
</line>
<line>
<line_number>20</line_number>
<line_content>from s3 import S3</line_content>
<context>
>>> import custom3</context>
</line>
<line>
<line_number>23</line_number>
<line_content>logging.basicConfig(stream=sys.stdout, level=logging.INFO)</line_content>
<context>
logging.basicConfig(level=logging.INFO)</context>
</line>
<line>
<line_number>26</line_number>
<line_content>load_dotenv()</line_content>
<context>
Py_GETENV(s)</context>
</line>
<line>
<line_number>27</line_number>
<line_content>if os.getenv('OPENAI_API_KEY') is None:</line_content>
<context>
f has_key example.py</context>
</line>
<line>
<line_number>28</line_number>
<line_content>st.error('OpenAI API key not set')</line_content>
<context>
Changed in version 3.10: Added the *key* parameter.</context>
</line>
<line>
<line_number>30</line_number>
<line_content>openai.api_key = os.getenv('OPENAI_API_KEY')</line_content>
<context>
self.key = key</context>
</line>
<line>
<line_number>33</line_number>
<line_content>s3 = S3('classgpt')</line_content>
<context>
class Song:</context>
</line>
<line>
<line_number>39</line_number>
<line_content>def parse_pdf(file: BytesIO):</line_content>
<context>
Python methods "int.to_bytes()" and "int.from_bytes()" to convert a "PyLongObject" to/from an array of bytes in base "256". You can call those from C using "PyObject_CallMethod()".</context>
</line>
<line>
<line_number>41</line_number>
<line_content>pdf = PdfReader(file)</line_content>
<context>
def reader():</context>
</line>
<line>
<line_number>42</line_number>
<line_content>text_list = []</line_content>
<context>
>>> a_list = []</context>
</line>
<line>
<line_number>44</line_number>
<line_content># Get the number of pages in the PDF document</line_content>
<context>
print(args.filename, args.count, args.verbose)</context>
</line>
<line>
<line_number>45</line_number>
<line_content>num_pages = len(pdf.pages)</line_content>
<context>
>>> print(len(s))</context>
</line>
<line>
<line_number>47</line_number>
<line_content># Iterate over every page</line_content>
<context>
Iteration</context>
</line>
<line>
<line_number>48</line_number>
<line_content>for page in range(num_pages):</line_content>
<context>
for i in range(10):</context>
</line>
<line>
<line_number>49</line_number>
<line_content># Extract the text from the page</line_content>
<context>
# Get resulting contents</context>
</line>
<line>
<line_number>50</line_number>
<line_content>page_text = pdf.pages[page].extract_text()</line_content>
<context>
the_page = response.read()</context>
</line>
<line>
<line_number>51</line_number>
<line_content>text_list.append(page_text)</line_content>
<context>
Append items from the list. This is equivalent to "for x in list: a.append(x)" except that if there is a type error, the array is unchanged.</context>
</line>
<line>
<line_number>53</line_number>
<line_content>text = '\n'.join(text_list)</line_content>
<context>
>>> line_list = ['  line 1\n', 'line 2  \n', ' \n', '']</context>
</line>
<line>
<line_number>55</line_number>
<line_content>return [Document(text)]</line_content>
<context>
print("Content</context>
</line>
<line>
<line_number>58</line_number>
<line_content>def create_index(pdf_obj, folder_name, file_name):</line_content>
<context>
file_created(path)</context>
</line>
<line>
<line_number>60</line_number>
<line_content>Create an index for a given PDF file and upload it to S3.</line_content>
<context>
"BZ2File" also provides the following method:</context>
</line>
<line>
<line_number>62</line_number>
<line_content>index_name = file_name.replace('.pdf', '.json')</line_content>
<context>
To rename a file, use "os.rename(old_path, new_path)".</context>
</line>
<line>
<line_number>64</line_number>
<line_content>logging.info('Generating new index...')</line_content>
<context>
logging.info('Doing something')</context>
</line>
<line>
<line_number>65</line_number>
<line_content>documents = parse_pdf(pdf_obj)</line_content>
<context>
file as file_obj: object</context>
</line>
<line>
<line_number>67</line_number>
<line_content>logging.info('Creating index...')</line_content>
<context>
logging.info('Doing something')</context>
</line>
<line>
<line_number>68</line_number>
<line_content>index = GPTSimpleVectorIndex(documents)</line_content>
<context>
index</context>
</line>
<line>
<line_number>70</line_number>
<line_content>with tempfile.TemporaryDirectory() as tmp_dir:</line_content>
<context>
with tempfile.NamedTemporaryFile(delete=False) as tmp_file:</context>
</line>
<line>
<line_number>71</line_number>
<line_content>tmp_path = f'{tmp_dir}/{index_name}'</line_content>
<context>
object_filenames(source_filenames[, strip_dir=0, output_dir=''])</context>
</line>
<line>
<line_number>72</line_number>
<line_content>logging.info('Saving index...')</line_content>
<context>
logging.info('Doing something')</context>
</line>
<line>
<line_number>73</line_number>
<line_content>index.save_to_disk(tmp_path)</line_content>
<context>
file_created(path)</context>
</line>
<line>
<line_number>75</line_number>
<line_content>with open(tmp_path, 'rb') as f:</line_content>
<context>
with open(sys.argv[1], 'rb') as f: data_to_send = f.read()</context>
</line>
<line>
<line_number>76</line_number>
<line_content>logging.info('Uploading index to s3...')</line_content>
<context>
logging.info('Doing something')</context>
</line>
<line>
<line_number>77</line_number>
<line_content>s3.upload_files(f, f'{folder_name}/{index_name}')</line_content>
<context>
Changed in version 3.3: Support was added for *filename* being a *file object* instead of an actual filename.</context>
</line>
<line>
<line_number>79</line_number>
<line_content>return index</line_content>
<context>
index</context>
</line>
<line>
<line_number>82</line_number>
<line_content>@st.cache_resource(show_spinner=False)</line_content>
<context>
The *cached_property* approach only works with methods that do not take any arguments. It does not create a reference to the instance. The cached method result will be kept only as long as the instance is alive.</context>
</line>
<line>
<line_number>83</line_number>
<line_content>def get_index(folder_name, file_name):</line_content>
<context>
def __getitem__(self, index):</context>
</line>
<line>
<line_number>85</line_number>
<line_content>Get the index for a given PDF file.</line_content>
<context>
index</context>
</line>
<line>
<line_number>87</line_number>
<line_content>index_name = file_name.replace('.pdf', '.json')</line_content>
<context>
To rename a file, use "os.rename(old_path, new_path)".</context>
</line>
<line>
<line_number>88</line_number>
<line_content>index = None</line_content>
<context>
index</context>
</line>
<line>
<line_number>90</line_number>
<line_content>if s3.file_exists(folder_name, index_name):</line_content>
<context>
If "run_filename" is set and is a directory which contains a</context>
</line>
<line>
<line_number>91</line_number>
<line_content>logging.info('Index found, loading index...')</line_content>
<context>
logging.info('Doing something')</context>
</line>
<line>
<line_number>92</line_number>
<line_content>with tempfile.TemporaryDirectory() as tmp_dir:</line_content>
<context>
with tempfile.NamedTemporaryFile(delete=False) as tmp_file:</context>
</line>
<line>
<line_number>93</line_number>
<line_content>tmp_path = f'{tmp_dir}/{index_name}'</line_content>
<context>
object_filenames(source_filenames[, strip_dir=0, output_dir=''])</context>
</line>
<line>
<line_number>94</line_number>
<line_content>s3.download_file(f'{folder_name}/{index_name}', tmp_path)</line_content>
<context>
object_filenames(source_filenames[, strip_dir=0, output_dir=''])</context>
</line>
<line>
<line_number>95</line_number>
<line_content>index = GPTSimpleVectorIndex.load_from_disk(tmp_path)</line_content>
<context>
Changed in version 3.8: Use "__index__()" if available.</context>
</line>
<line>
<line_number>98</line_number>
<line_content>logging.info('Index not found, generating index...')</line_content>
<context>
logging.info('Doing something')</context>
</line>
<line>
<line_number>99</line_number>
<line_content>with tempfile.NamedTemporaryFile('wb') as f_src:</line_content>
<context>
with tempfile.NamedTemporaryFile(delete=False) as tmp_file:</context>
</line>
<line>
<line_number>100</line_number>
<line_content>logging.info(f'{file_name} downloaded')</line_content>
<context>
"filename": "app.log",</context>
</line>
<line>
<line_number>101</line_number>
<line_content>s3.download_file(f'{folder_name}/{file_name}', f_src.name)</line_content>
<context>
object_filenames(source_filenames[, strip_dir=0, output_dir=''])</context>
</line>
<line>
<line_number>103</line_number>
<line_content>with open(f_src.name, 'rb') as f:</line_content>
<context>
with open(file) as f:</context>
</line>
<line>
<line_number>104</line_number>
<line_content>index = create_index(f, folder_name, file_name)</line_content>
<context>
file_created(path)</context>
</line>
<line>
<line_number>106</line_number>
<line_content>return index</line_content>
<context>
index</context>
</line>
<line>
<line_number>109</line_number>
<line_content>def query_gpt(chosen_class, chosen_pdf, query):</line_content>
<context>
"PyClassMethodDescr_Type"</context>
</line>
<line>
<line_number>111</line_number>
<line_content>if not os.getenv('OPENAI_API_KEY'):</line_content>
<context>
self.key = key</context>
</line>
<line>
<line_number>112</line_number>
<line_content>st.error('Enter your OpenAI API key in the sidebar.')</line_content>
<context>
Due to the compatibility problem noted above, this version of the API should not be used in new code.</context>
</line>
<line>
<line_number>115</line_number>
<line_content># LLM Predictor (gpt-3.5-turbo)</line_content>
<context>
%m</context>
</line>
<line>
<line_number>116</line_number>
<line_content>llm_predictor = LLMPredictor(</line_content>
<context>
Changed in version 3.2: Support for ""%lld"" and ""%llu"" added.</context>
</line>
<line>
<line_number>117</line_number>
<line_content>llm=ChatOpenAI(</line_content>
<context>
return m;</context>
</line>
<line>
<line_number>118</line_number>
<line_content>temperature=0,</line_content>
<context>
temp;</context>
</line>
<line>
<line_number>119</line_number>
<line_content>model_name='gpt-3.5-turbo',</line_content>
<context>
PyType_Spec.name</context>
</line>
<line>
<line_number>123</line_number>
<line_content>index = get_index(chosen_class, chosen_pdf)</line_content>
<context>
Changed in version 3.8: Use "__index__()" if available.</context>
</line>
<line>
<line_number>124</line_number>
<line_content>response = index.query(query, llm_predictor=llm_predictor)</line_content>
<context>
return conn.execute(self.fetch, [obj.key]).fetchone()[0]</context>
</line>
<line>
<line_number>126</line_number>
<line_content># logging.info(response.get_formatted_sources())</line_content>
<context>
logging.Formatter.__init__(fmt=None, datefmt=None, style='%')</context>
</line>
<line>
<line_number>128</line_number>
<line_content>return response</line_content>
<context>
return</context>
</line>
<line>
<line_number>131</line_number>
<line_content>@st.cache_resource</line_content>
<context>
"tp_cache"</context>
</line>
<line>
<line_number>132</line_number>
<line_content>def create_tool(_index, chosen_pdf):</line_content>
<context>
Py_mod_create</context>
</line>
<line>
<line_number>135</line_number>
<line_content>name=f'{chosen_pdf} index',</line_content>
<context>
Changed in version 3.8: Use "__index__()" if available.</context>
</line>
<line>
<line_number>136</line_number>
<line_content>func=lambda q: str(_index.query(q)),</line_content>
<context>
4. Convert the lambda to a def statement, using that name.</context>
</line>
<line>
<line_number>137</line_number>
<line_content>description='Useful to answering questions about the given file',</line_content>
<context>
Most calls to the "ArgumentParser" constructor will use the "description=" keyword argument. This argument gives a brief description of what the program does and how it works. In help messages, the description is displayed between the command-line usage string and the help messages for the various arguments:</context>
</line>
<line>
<line_number>138</line_number>
<line_content>return_direct=True,</line_content>
<context>
Py_RETURN_TRUE</context>
</line>
<line>
<line_number>142</line_number>
<line_content>return tools</line_content>
<context>
return</context>
</line>
<line>
<line_number>145</line_number>
<line_content>@st.cache_resource</line_content>
<context>
"tp_cache"</context>
</line>
<line>
<line_number>146</line_number>
<line_content>def create_agent(chosen_class, chosen_pdf):</line_content>
<context>
def get_defining_class(self):</context>
</line>
<line>
<line_number>147</line_number>
<line_content>memory = ConversationBufferMemory(memory_key='chat_history')</line_content>
<context>
async_chat.collect_incoming_data(data)</context>
</line>
<line>
<line_number>148</line_number>
<line_content>llm = OpenAI(temperature=0, model_name='gpt-3.5-turbo')</line_content>
<context>
def current_temperature(self): "Latest hourly observation" # Do not cache this because old results # can be out of date.</context>
</line>
<line>
<line_number>150</line_number>
<line_content>index = get_index(chosen_class, chosen_pdf)</line_content>
<context>
Changed in version 3.8: Use "__index__()" if available.</context>
</line>
<line>
<line_number>151</line_number>
<line_content>tools = create_tool(index, chosen_pdf)</line_content>
<context>
Installing the tools</context>
</line>
<line>
<line_number>153</line_number>
<line_content>agent = initialize_agent(</line_content>
<context>
"Py_Initialize()"</context>
</line>
<line>
<line_number>154</line_number>
<line_content>tools, llm, agent='conversational-react-description', memory=memory</line_content>
<context>
MemoryHandler</context>
</line>
<line>
<line_number>157</line_number>
<line_content>return agent</line_content>
<context>
return</context>
</line>
<line>
<line_number>160</line_number>
<line_content>def query_gpt_memory(chosen_class, chosen_pdf, query):</line_content>
<context>
objects. The memory is taken from the Python private heap.</context>
</line>
<line>
<line_number>162</line_number>
<line_content>agent = create_agent(chosen_class, chosen_pdf)</line_content>
<context>
def get_defining_class(self):</context>
</line>
<line>
<line_number>166</line_number>
<line_content>res = agent.run(input=query)</line_content>
<context>
req = urllib.request.Request('http://python.org/')</context>
</line>
<line>
<line_number>167</line_number>
<line_content>except Exception as e:</line_content>
<context>
except Exception:</context>
</line>
<line>
<line_number>168</line_number>
<line_content>logging.error(e)</line_content>
<context>
logging.error('An ERROR message')</context>
</line>
<line>
<line_number>169</line_number>
<line_content>res = 'Something went wrong... Please try again.'</line_content>
<context>
res = None</context>
</line>
<line>
<line_number>171</line_number>
<line_content>st.session_state.memory = agent.memory.buffer</line_content>
<context>
11. "MemoryHandler" instances send messages to a buffer in memory, which is flushed whenever specific criteria are met.</context>
</line>
<line>
<line_number>173</line_number>
<line_content>return res</line_content>
<context>
res = None</context>
</line>
<line>
<line_number>179</line_number>
<line_content>@st.cache_data</line_content>
<context>
"tp_cache"</context>
</line>
<line>
<line_number>180</line_number>
<line_content>def show_pdf(folder_name, file_name):</line_content>
<context>
filename will be inferred from the library name. *output_dir*</context>
</line>
<line>
<line_number>182</line_number>
<line_content>with tempfile.NamedTemporaryFile('wb') as f_src:</line_content>
<context>
with tempfile.NamedTemporaryFile(delete=False) as tmp_file:</context>
</line>
<line>
<line_number>183</line_number>
<line_content>logging.info(f'Downloading {file_name}...')</line_content>
<context>
logging.info('Doing something')</context>
</line>
<line>
<line_number>184</line_number>
<line_content>s3.download_file(f'{folder_name}/{file_name}', f_src.name)</line_content>
<context>
object_filenames(source_filenames[, strip_dir=0, output_dir=''])</context>
</line>
<line>
<line_number>186</line_number>
<line_content>with open(f_src.name, 'rb') as f:</line_content>
<context>
with open(file) as f:</context>
</line>
<line>
<line_number>187</line_number>
<line_content>base64_pdf = base64.b64encode(f.read()).decode('utf-8')</line_content>
<context>
base64.decode(input, output)</context>
</line>
<line>
<line_number>189</line_number>
<line_content>pdf_display = f'''</line_content>
<context>
"PyErr_Display()"</context>
</line>
<line>
<line_number>191</line_number>
<line_content>src='data:application/pdf;base64,{base64_pdf}'</line_content>
<context>
Valid base64:</context>
</line>
<line>
<line_number>192</line_number>
<line_content>width='100%' height='1000'</line_content>
<context>
width</context>
</line>
<line>
<line_number>193</line_number>
<line_content>type='application/pdf'</line_content>
<context>
FileType objects</context>
</line>
<line>
<line_number>194</line_number>
<line_content>style='min-width: 400px;'</line_content>
<context>
Use of alternative formatting styles ====================================</context>
</line>
<line>
<line_number>199</line_number>
<line_content>st.markdown(pdf_display, unsafe_allow_html=True)</line_content>
<context>
print("Content-Type: text/html")    # HTML is following print()                             # blank line, end of headers
</context>
</line>
</file_context>
</file>
</files>